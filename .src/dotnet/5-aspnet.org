#+TITLE: ASP.NET


* 单机 到 CS 到 BS

要注意，.NET 跟 C# 不是一样的概念：
:    编译器                  运行
: C#   ->   中间码(IL) ->   (.NET)  -> 机器码
: F#
: VB
: JS
: Java
: 
: .java -> .class -> (JVM) -> 机器码
: kotlin
: groovy
: clojue
: scala

经典、传统软件 (桌面软件):
- 语言: C/C++/C#/Java/OC/Swift
- 技术: Winform/WPF/UWP/MaUI Qt/GTK

单机软件不符合应用场景，多机协助成了最大需求。
最终，出现了 CS (Client-Server) 架构。
- 多机通信使用 Socket，但是 Socket 需要处理太多细节，比较麻烦
- 都要从 0 开始构建底层界面
- BS 能干的事情，CS *一定* 可以做到而且可以干的更好，但是 CS 要花费更高的 *成本*
- CS 能干的事情，BS 不一定能做到。CS 的客户端可以对系统进行完全的控制，它可以实现浏览器无法实现的很多行为
- BS 架构，通过放弃了一些东西，成功降低了各种成本:
  + 学习成本低
  + 开发成本低
  + 使用成本低

#+begin_src html
  <h1>标题</h1>
  <form action="xxx">
    <input type="submit" value="点我发送" />
  </form>
#+end_src

任务: 
- 什么是 CS 架构，什么是 BS 架构?
- CS 架构跟 BS 架构相比，各有什么优劣?
- 整理资料，了解浏览器的发展历史

360/....很多野生浏览器:
- 当时 IE 你不能不用，而且多个版本之间还有差别。IE6
- 当时先进生产力的代表是 Firefox, Chrome, Opera 等更加贴近标准的浏览器
- 双(多)核浏览器+兼容


* ASP -> ASP.NET -> ASP.NET Core

大致分为三个阶段:
1. 1996 年左右，ASP (Active Server Page), 使用的开发语言是 VB
2. 2002 年左右，随着 .NET 平台出现，推出了 ASP.NET 技术
3. 2015 年左右，微软开始推出跨平台的 .NET，称作 .NET Core

* ASP.NET (Framework)

Pipeline (管道/管线) 模型:
- 最核心的接口: ~IHttpHandler/IHttpHandlerFactory~, ~IHttpModule~
- 最核心的配置文件: Web.config
- 比较重要的类: HttpApplication, HttpContext

Pipeline 中标准的 19 个事件:
[[file:img/oimg_20220920_070127.png]]
Global.asax:
- Application_Start/End
- Session_Start/End
- Application_BeginRequest/AuthenticateRequest/Error

部署:
- 环境: Windows + SqlServer + IIS
- IIS 是缩写，全称 Internet Information Services (互联网信息服务 ), 是由微软公司提供的基于运行 .NET 的互联网基本服务。
- 步骤: 
  1. 开发项目，通过【发布】导出要部署的项目文件夹
  2. 在服务器上安 Windows 操作系统
  3. 在 Windows 中安装 SqlServer 数据库
  4. 在 Windows 中启用 IIS 服务器
  5. 在 IIS 管理器中，为项目文件夹创建新的【网站】
  6. 注意整个过程中的【权限】和【防火墙】问题


* ASP.NET Webform
** aspx 文件

首先，可以将 aspx 文件看做一个加强版的 html 文件，所以，它完全接受 html 语法。

因此创建一个 Hello.aspx 文件，内容如下:
#+begin_src html
  <html>
    <h1>我是 Hello.aspx 文件，所有的 html 代码在这里都会被原样返回给浏览器</h1>
    <p> 其他的或简单或复杂的 html/js/css 代码 </p>
  </html>
#+end_src

运行项目，可以通过 ~https://localhost:port/Hello.aspx~ 访问这个页面。浏览器中查看源代码可以看到内容跟上述一致。

接下来，aspx 接受行内表达式语法。这种语法来源于之前的 asp 时代，是在 html 内嵌 C#/VB 代码的一种方式 ([[https://learn.microsoft.com/en-us/troubleshoot/developer/webapps/aspnet/development/inline-expressions][官方链接]])。
#+begin_src html
  <html>
    <h1>我是 Hello.aspx 文件，所有的 html 代码在这里都会被原样返回给浏览器</h1>
    <p> 其他的或简单或复杂的 html/js/css 代码 </p>
    <div>
      <% Response.Write("通过行内表达式，可以在文件中嵌入 C# 代码了！"); %>
      <% Response.Write(Request.UserAgent); %>
      <%
        string a = "可以写很多代码，在这里"; 
        string c = "现在，定义一个变量，后面使用";
      %>

      <% Response.Write(c); %>
      <%-- 我是一个注释: 下面的一行代码，是上面代码的语法糖 --%>
      <%= c >

      <%= "<div>你好</div>" %>
      <%-- 使用 %: 进行自动格式化输出 --%>
      <% Response.Write(HttpUtility.HtmlEncode("<div>你好</div>")); %>
      <%= HttpUtility.HtmlEncode("<div>你好</div>") %>
      <%: "<div>你好</div>" %>

      <%# Button1.Controls %>
      <%#: Button1.Controls %>
    </div>
  </html>
#+end_src

微软说，时代变了，行内表达式容易导致逻辑跟页面混淆，不便于维护和复用。亲，建议使用控件。
控件的使用方法，跟 Winform 中实在太像了:
#+begin_src html
  <html>
    <form id="form1" runat="server">
       <asp:Calendar ID="Calendar1" runat="server"></asp:Calendar>
       <asp:Button ID="Button1" runat="server" OnClick="Button1_Click" Text="Button" />
    </form>
  </html>
#+end_src

如果是方法等大段的 C# 代码，可以写在 script runat server 里面:
#+begin_src html
  <html>
    <script runat="server">
        public string MyName = "真难";
        public string HelloWorld() { return "HelloWorld"; }
        public string MyCalender() { return "<div>我是一个巨复杂的日历</div>"; }
        protected void Button1_Click(object sender, EventArgs e) { }
    </script>

    <%= MyCalender() %>
    <asp:Calendar ID="Calendar1" runat="server"></asp:Calendar>
  </html>
#+end_src

但是上述 C# 代码写在 aspx 文件里，开发成本和维护成本都比较高，所以能不能有一种机制将其​*分离*​出去?
有的，有的。使用页面指令，指定外部 csharp 文件即可:
#+begin_src html
  <%@ Page Language="C#" AutoEventWireup="true" CodeBehind="Balala.cs" Inherits="WebApplication2.Balala" %>
#+end_src

于是，就可以创建文件 Balala.cs 在里面专注于数据和业务逻辑，之后让 aspx 专注于页面展现了（模型与视图分离的思想）。

这个 Balala.cs 需要写成类似这个样子:
#+begin_src csharp
  namespace WebApplication2
  {
      public partial class Balala : Page
      {
          public string MyName = "真难";
          public string HelloWorld()
          {
              return "HelloWorld";
          }
          public string MyCalender()
          {
              return "<div>我是一个巨复杂的日历</div>";
          }
          protected void Button1_Click(object sender, EventArgs e)
          {
          }
      }
  }
#+end_src

通过以上操作，一个完整的 Web 窗体就有了。

另外，不同的页面往往在整体的布局存在很多相似之处，不同页面存在大量雷同代码。
为了简化在 aspx 中构建页面，可以通过母版的方式，将整体的页面布局代码分离到外面 (挖坑-填坑)，
达到共用布局的目的。

方法很简单，首先，要创建一个母版文件。它跟 aspx 很像，只是文件的后缀和页面指令不同。比如，创建一个 yyy.Master 母版:
#+begin_src html
  <%@ Master Language="C#" %>

  <html>
  <head>
      <title></title>
      <asp:ContentPlaceHolder ID="head" runat="server" />
  </head>
  <body>
      <aside>
          菜单
      </aside>
      <div class="main">
          <asp:ContentPlaceHolder ID="main" runat="server" />
      </div>
  </body>
  </html>
#+end_src

通过使用 ~asp:ContentPlaceHolder~ 挖坑。使用这个母版的 aspx 文件，只需要用 ~asp:Content~ 填坑即可。

#+begin_src html
  <%@ Page Language="C#" AutoEventWireup="true"
      MasterPageFile="~/yyy.Master"
      CodeBehind="WebForm2.aspx.cs" Inherits="WebApplication2.WebForm2" %>

  <asp:Content runat="server" ContentPlaceHolderID="head">
      <style>
          .main {
              background: lightyellow;
              height: 200px;
          }
      </style>
  </asp:Content>

  <asp:Content runat="server" ContentPlaceHolderID="main">
      <div style="color: red;">
          我是另外的一个页面
      </div>
  </asp:Content>
#+end_src

就这样，就实现了页面布局的可重复使用。编码可以更灵活了。

** Page 类

你 (Browser) 请求 http://localhost:893232/Hello.aspx 到我 (IIS):
- 首先，查找 aspx 有没有对应的编译文件。如果有，执行之；否则，先编译，后执行之
- aspx 会被动态转换为相应的 csharp 文件，之后会被编译进 dll 中 (HttpRuntime.CodegenDir)
- aspx 文件实质是 ~Page~ 的一个子类，它实现了 ~IHttpHandler~ 接口
- aspx 还实现了 ~IRequiresSessionState~ 接口，因此可以在 aspx 中自由使用 Session
- 在父类 Page 中，定义了控件加载的逻辑和页面渲染的逻辑
- 在父类 Page 中，初始化了很多属性和方法，可以直接使用
- 因此，掌握 Page 类的​*生命周期*和 Page 的基本方法属性非常重要

** Page 生命周期

[[file:img/oimg_20220928_005325.png]]

PreInit:
#+begin_src csharp
  protected void Page_PreInit(object sender, EventArgs e)
  {
      // 1. 通过检查 IsPostBack 来确定页面是否是第一次被加载
      // 2. 创建(或重建)服务器控件
      // 3. 设置母版 (Master)
      // 4. 设置主题 (Theme)
      // 注意: 如果页面是 postback 那么控件的值还没有被恢复，因此你在这个阶段设置的控件值也许会被覆盖
  }
#+end_src

Init:
#+begin_src csharp
  protected void Page_Init(object sender, EventArgs e)
  {
      // 1. 这个事件是在所有控件都被初始化之后被触发的
      // 2. 为每个控件设置 UniqueID，并且应用皮肤
      // 3. 可以使用这个事件来读取或初始化控件的属性（！！！）
      // 4. 在控件树中，Init 事件是由内而外的顺序触发的
  }
#+end_src

InitComplete:
#+begin_src csharp
  protected void Page_InitComplete(object sender, EventArgs e)
  {
      // 1. 在这个阶段，viewstate 值还没有被加载。
      //    因此您可以使用此事件对视图状态进行更改，以确保在下一次 postback 后保留这些更改
      // 2. 这个事件是被 Page 对象触发的
      // 3. 如果需要所有初始化工作完成才能执行的任务，可以写在这里
  }
#+end_src

OnPreLoad:
#+begin_src csharp
  protected void OnPreLoad(object sender, EventArgs e)
  {
      // 是在 Page 对象已经加载了 ViewState 中的值、并加载完成所有控件、并通过 request 参数处理完 postback 数据之后，才触发的
  }
#+end_src

Load:
#+begin_src csharp
  protected void Page_Load(object sender, EventArgs e)
  {
      // 1. Page 对象会执行 Page 上面的 OnLoad 方法，然后递归地执行子控件的 OnLoad 方法
      // 2. 这是在生命周期中，第一个所有的值都被完全恢复了的阶段
      // 3. 绝大多数情况下，可以通过检查 IsPostBack 的值来避免不必要的重置状态
      // 4. 在这里，适合进行输入验证
      // 5. 在这里，适合动态创建、添加组件
      // 6. 在这里，适合调整控件的属性，适合创建数据库连接
  }
#+end_src

控件上的 PostBack 事件:
#+begin_src csharp
  protected void Button1_Click(object sender, EventArgs e)
  {
      // 1. ASP.NET 现在会调用所有在 Page 或子控件上的能导致 PostBack 的事件
      // 2. 使用这些事件，可以处理比如 Button 点击、TextBox 的文本变动等
  }
#+end_src

LoadComplete:
#+begin_src csharp
  protected void Page_LoadComplete(object sender, EventArgs e)
  {
      // 1. 在事件处理阶段的最后被触发的
      // 2. 这里适合所有的其他控件都被完全加载之后的任务
  }
#+end_src

OnPreRender:
#+begin_src csharp
  protected void OnPreRender(object sender, EventArgs e)
  {
      // 1. 在所有的对象都已经完全准备好的情况下触发的
      // 2. 先是 Page 上的 OnPreRender 被执行，然后递归执行子控件上的 OnPreRender
      // 3. 允许对页面或其控件进行最终更改
      // 4. 这个事件发生在保存 ViewState 之前，所以在这里做的任何修改都将被保存
      // 5. 设置了 DataSourceID 属性的每个数据绑定控件都调用其 DataBind 方法
      // 6. 这里适合用来对 Page 或控件进行最后的调整
  }
#+end_src

OnSaveStateComplete:
#+begin_src csharp
  protected void OnSaveStateComplete(object sender, EventArgs e)
  {
      // 1. 在页面和控件的 ViewState 已经被保存之后触发
      // 2. 在这里对页面或控件的修改，会被忽略掉
      // 3. 这里适合不想改变 ViewState 的一些善后工作
  }
#+end_src

Render-Method:
- Render 方法存在于 Page 对象和其子控件中
- 这个阶段，其实就是 ASP.NET 拼接 html 字符串，响应给用户的过程

Unload:
#+begin_src csharp
  protected void Page_Unload(object sender, EventArgs e)
  {
      // 1. 这个方法用来进行清理工作
      // 2. 在这个阶段，所有工作都已经完成，可以放心释放任何资源，包括 Page 对象
      // 3. 在这里，不能使用 Response.Write 输出内容，否则会报错
  }
#+end_src

参考: https://www.c-sharpcorner.com/UploadFile/8911c4/page-life-cycle-with-examples-in-Asp-Net/

** 数据控件
*** GridView

https://learn.microsoft.com/zh-cn/dotnet/api/system.web.ui.webcontrols.gridview?view=netframework-4.8

最简方式:
#+begin_src html
  <asp:SqlDataSource ID="DS1" runat="server"
                     SelectCommand="select * from students"
                     ConnectionString="<%$ ConnectionStrings: mydb %>" />
  <asp:GridView DataSourceID="DS1" runat="server" />
#+end_src

编程方式的数据源:
#+begin_src csharp
  studentsGV.DataSource = 
      DbHelper.DoExecuteQuery("select * from students");
  studentsGV.DataBind();
#+end_src
#+begin_src html
  <asp:GridView ID="studentsGV" runat="server" />
#+end_src

灵活定义视图格式:
#+begin_src html
  <asp:GridView ID="studentsGV" runat="server"
      ShowFooter="true" 
      AutoGenerateColumns="false"
      AllowSorting="true"
      EmptyDataText="没有查询到任何学生">
      <Columns>
          <asp:BoundField DataField="name" HeaderText="姓名" SortExpression="id"/>
          <asp:BoundField DataField="homecity" />
          <asp:ButtonField ButtonType="Link" Text="dksk" />
          <asp:CommandField ShowDeleteButton="true" ShowEditButton="true" />
          <asp:TemplateField>
              <ItemTemplate>
                  <div>
                      <p><%# Eval("name") %> (<%# Eval("homecity") %>)</p>
                      <h3 style="color: red">我是谁</h3>
                      <h5 style="color: green">我就是我，不一样的烟火</h5>
                      <asp:Button ID="dddd" runat="server" Text="我是按钮" />
                  </div>
              </ItemTemplate>
              <ItemStyle BackColor="Green" />
          </asp:TemplateField>
      </Columns>
      <AlternatingRowStyle BackColor="LightBlue" Font-Size="XX-Large"/>
      <HeaderStyle BackColor="Gray" />
  </asp:GridView>
#+end_src

* ASP.NET MVC

MVC:
- Model (模型)
- View  (视图)
- Controller (控制器)
