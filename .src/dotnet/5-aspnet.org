#+TITLE: ASP.NET


* .NET
** 历史

上世纪 90 年代末，Windows 上的开发技术分化成了多个部分:
- 精通 C/C++ 程序员，他们喜欢直接面对 Windows API 进行编程
- 有一部分人就转向了 MFC (Microsoft Foundation Class)
- COM 编程

上述技术都存在一些问题或短板。为了应对 Internet 潮流的到来，微软决定推出新一代的技术框架。
2002 年的时候，.NET 平台就出现了。刚开始主要使用 VB，后面全面转向了 C#。

发展至今，.NET 平台现在主要有 3 个版本:
- .NET Framework
  + 微软把控
  + 只能运行在 Windows 平台上面
  + 最新的版本 (2022-10-25) 是 4.8
  + 是内置在 Windows 操作系统下的平台
- Mono
  + 由 Ximian 公司主持创建的开源项目，2004 年推出第一个版本
  + 目标是创建一个跨平台的 .NET 实现
  + Unity3D 是基于 Mono
  + Xamarin 框架也是基于 Mono
- .NET Core
  + 2016 年，微软决定将 .NET 平台开源并且跨平台。这时候将 Mono 收购了
  + 微软决定，留两个跨平台的运行时 (Mono + .Net Core)，Core 是从头实现的
  + Core:
    * 将 MVC 和 Web API 移植到了 Core 中，但是 Webform 和 WCF 等被移除了
    * Entity Framework 多年以来背负了沉重的历史包袱，因此 Core 中将其精简了，并且加入了对非关系型数据库的支持
    * 微软将很多 .NET 中自带的功能抽取剥离出来放到了 NuGet 包里。这样 .NET 的核心就变得更小，而且没有太多的依赖
    * 使用 Windows Desktop pack 的方法运行 Winform/WPF 等，从而可以让 Windows 上面支持更多未移植的功能
      
2020.11，微软决定，将原本要推出的 .NET Core 3.1 改名为 .NET5，并承诺未来只有一个 .NET 平台，每年将会推出一个新的版本。

** 规范

为了保持多个平台之间的一致性，防止出现碎片化和分化，微软推出了 *.NET Standard* (标准/规范):
- https://github.com/dotnet/standard/blob/v2.1.0/docs/versions/netstandard2.1.md
- 它提供了一系列的 API 规范。要求所有的平台都要去实现这些 API
- .NET Framework 支持到了 Standard 2.0，Core 和 Mono 支持到了 2.1。C# 8 的一些特性需要 2.1 标准的支持

为了让不同的编程语言都能在 .NET 平台上和谐有序协作运行，微软定义了一系列的规范，称作 *CLI* (Common Language Infrastructure，即通用语言基础设施):
- 通过 CLS (Common Language Specification) 阐述了运行在平台上的诸多语言需要遵循的基本规范
- 通过 CTS (Common Type System) 定义了 .NET 平台上通用的内置类型，包括但不限于对象模型、基本元数组类型的库等
- 通过 *CIL* (Common Intermedia Language) 规范了编译成的中间码的格式跟规范
- 它还包括 CLR/BCL/Metadata 等的定义 (CLR 可以看做 CLI 规范的一个实现）
- 注: .NET = *SDK* (Software Development Kit, 开发工具包) + *CLR* (Common Language Runtime，通用运行时)
- 后来 CLI 被提交到了国际化标准组织，成为了一个通用的国际标准

* 单机 到 CS 到 BS

要注意，.NET 跟 C# 不是一样的概念：
:    编译器                  运行
: C#   ->   中间码(IL) ->   (.NET)  -> 机器码
: F#
: VB
: JS
: Java
:
: .java -> .class -> (JVM) -> 机器码
: kotlin
: groovy
: clojue
: scala

经典、传统软件 (桌面软件):
- 语言: C/C++/C#/Java/OC/Swift
- 技术: Winform/WPF/UWP/MaUI Qt/GTK

单机软件不符合应用场景，多机协助成了最大需求。
最终，出现了 CS (Client-Server) 架构。
- 多机通信使用 Socket，但是 Socket 需要处理太多细节，比较麻烦
- 都要从 0 开始构建底层界面
- BS 能干的事情，CS *一定* 可以做到而且可以干的更好，但是 CS 要花费更高的 *成本*
- CS 能干的事情，BS 不一定能做到。CS 的客户端可以对系统进行完全的控制，它可以实现浏览器无法实现的很多行为
- BS 架构，通过放弃了一些东西，成功降低了各种成本:
  + 学习成本低
  + 开发成本低
  + 使用成本低

#+begin_src html
  <h1>标题</h1>
  <form action="xxx">
    <input type="submit" value="点我发送" />
  </form>
#+end_src

任务:
- 什么是 CS 架构，什么是 BS 架构?
- CS 架构跟 BS 架构相比，各有什么优劣?
- 整理资料，了解浏览器的发展历史

360/....很多野生浏览器:
- 当时 IE 你不能不用，而且多个版本之间还有差别。IE6
- 当时先进生产力的代表是 Firefox, Chrome, Opera 等更加贴近标准的浏览器
- 双(多)核浏览器+兼容


* ASP -> ASP.NET -> ASP.NET Core

大致分为三个阶段:
1. 1996 年左右，ASP (Active Server Page), 使用的开发语言是 VB
2. 2002 年左右，随着 .NET 平台出现，推出了 ASP.NET 技术
3. 2015 年左右，微软开始推出跨平台的 .NET，称作 .NET Core

* ASP.NET (Framework)

Pipeline (管道/管线) 模型:
- 最核心的接口: ~IHttpHandler/IHttpHandlerFactory~, ~IHttpModule~
- 最核心的配置文件: Web.config
- 比较重要的类: HttpApplication, HttpContext

Pipeline 中标准的 19 个事件:
[[file:img/oimg_20220920_070127.png]]
Global.asax:
- Application_Start/End
- Session_Start/End
- Application_BeginRequest/AuthenticateRequest/Error

部署:
- 环境: Windows + SqlServer + IIS
- IIS 是缩写，全称 Internet Information Services (互联网信息服务 ), 是由微软公司提供的基于运行 .NET 的互联网基本服务。
- 步骤:
  1. 开发项目，通过【发布】导出要部署的项目文件夹
  2. 在服务器上安 Windows 操作系统
  3. 在 Windows 中安装 SqlServer 数据库
  4. 在 Windows 中启用 IIS 服务器
  5. 在 IIS 管理器中，为项目文件夹创建新的【网站】
  6. 注意整个过程中的【权限】和【防火墙】问题


* ASP.NET Webform
** aspx 文件

首先，可以将 aspx 文件看做一个加强版的 html 文件，所以，它完全接受 html 语法。

因此创建一个 Hello.aspx 文件，内容如下:
#+begin_src html
  <html>
    <h1>我是 Hello.aspx 文件，所有的 html 代码在这里都会被原样返回给浏览器</h1>
    <p> 其他的或简单或复杂的 html/js/css 代码 </p>
  </html>
#+end_src

运行项目，可以通过 ~https://localhost:port/Hello.aspx~ 访问这个页面。浏览器中查看源代码可以看到内容跟上述一致。

接下来，aspx 接受行内表达式语法。这种语法来源于之前的 asp 时代，是在 html 内嵌 C#/VB 代码的一种方式 ([[https://learn.microsoft.com/en-us/troubleshoot/developer/webapps/aspnet/development/inline-expressions][官方链接]])。
#+begin_src html
  <html>
    <h1>我是 Hello.aspx 文件，所有的 html 代码在这里都会被原样返回给浏览器</h1>
    <p> 其他的或简单或复杂的 html/js/css 代码 </p>
    <div>
      <% Response.Write("通过行内表达式，可以在文件中嵌入 C# 代码了！"); %>
      <% Response.Write(Request.UserAgent); %>
      <%
        string a = "可以写很多代码，在这里";
        string c = "现在，定义一个变量，后面使用";
      %>

      <% Response.Write(c); %>
      <%-- 我是一个注释: 下面的一行代码，是上面代码的语法糖 --%>
      <%= c >

      <%= "<div>你好</div>" %>
      <%-- 使用 %: 进行自动格式化输出 --%>
      <% Response.Write(HttpUtility.HtmlEncode("<div>你好</div>")); %>
      <%= HttpUtility.HtmlEncode("<div>你好</div>") %>
      <%: "<div>你好</div>" %>

      <%# Button1.Controls %>
      <%#: Button1.Controls %>
    </div>
  </html>
#+end_src

微软说，时代变了，行内表达式容易导致逻辑跟页面混淆，不便于维护和复用。亲，建议使用控件。
控件的使用方法，跟 Winform 中实在太像了:
#+begin_src html
  <html>
    <form id="form1" runat="server">
       <asp:Calendar ID="Calendar1" runat="server"></asp:Calendar>
       <asp:Button ID="Button1" runat="server" OnClick="Button1_Click" Text="Button" />
    </form>
  </html>
#+end_src

如果是方法等大段的 C# 代码，可以写在 script runat server 里面:
#+begin_src html
  <html>
    <script runat="server">
        public string MyName = "真难";
        public string HelloWorld() { return "HelloWorld"; }
        public string MyCalender() { return "<div>我是一个巨复杂的日历</div>"; }
        protected void Button1_Click(object sender, EventArgs e) { }
    </script>

    <%= MyCalender() %>
    <asp:Calendar ID="Calendar1" runat="server"></asp:Calendar>
  </html>
#+end_src

但是上述 C# 代码写在 aspx 文件里，开发成本和维护成本都比较高，所以能不能有一种机制将其​*分离*​出去?
有的，有的。使用页面指令，指定外部 csharp 文件即可:
#+begin_src html
  <%@ Page Language="C#" AutoEventWireup="true" CodeBehind="Balala.cs" Inherits="WebApplication2.Balala" %>
#+end_src

于是，就可以创建文件 Balala.cs 在里面专注于数据和业务逻辑，之后让 aspx 专注于页面展现了（模型与视图分离的思想）。

这个 Balala.cs 需要写成类似这个样子:
#+begin_src csharp
  namespace WebApplication2
  {
      public partial class Balala : Page
      {
          public string MyName = "真难";
          public string HelloWorld()
          {
              return "HelloWorld";
          }
          public string MyCalender()
          {
              return "<div>我是一个巨复杂的日历</div>";
          }
          protected void Button1_Click(object sender, EventArgs e)
          {
          }
      }
  }
#+end_src

通过以上操作，一个完整的 Web 窗体就有了。

另外，不同的页面往往在整体的布局存在很多相似之处，不同页面存在大量雷同代码。
为了简化在 aspx 中构建页面，可以通过母版的方式，将整体的页面布局代码分离到外面 (挖坑-填坑)，
达到共用布局的目的。

方法很简单，首先，要创建一个母版文件。它跟 aspx 很像，只是文件的后缀和页面指令不同。比如，创建一个 yyy.Master 母版:
#+begin_src html
  <%@ Master Language="C#" %>

  <html>
  <head>
      <title></title>
      <asp:ContentPlaceHolder ID="head" runat="server" />
  </head>
  <body>
      <aside>
          菜单
      </aside>
      <div class="main">
          <asp:ContentPlaceHolder ID="main" runat="server" />
      </div>
  </body>
  </html>
#+end_src

通过使用 ~asp:ContentPlaceHolder~ 挖坑。使用这个母版的 aspx 文件，只需要用 ~asp:Content~ 填坑即可。

#+begin_src html
  <%@ Page Language="C#" AutoEventWireup="true"
      MasterPageFile="~/yyy.Master"
      CodeBehind="WebForm2.aspx.cs" Inherits="WebApplication2.WebForm2" %>

  <asp:Content runat="server" ContentPlaceHolderID="head">
      <style>
          .main {
              background: lightyellow;
              height: 200px;
          }
      </style>
  </asp:Content>

  <asp:Content runat="server" ContentPlaceHolderID="main">
      <div style="color: red;">
          我是另外的一个页面
      </div>
  </asp:Content>
#+end_src

就这样，就实现了页面布局的可重复使用。编码可以更灵活了。

** Page 类

你 (Browser) 请求 http://localhost:893232/Hello.aspx 到我 (IIS):
- 首先，查找 aspx 有没有对应的编译文件。如果有，执行之；否则，先编译，后执行之
- aspx 会被动态转换为相应的 csharp 文件，之后会被编译进 dll 中 (HttpRuntime.CodegenDir)
- aspx 文件实质是 ~Page~ 的一个子类，它实现了 ~IHttpHandler~ 接口
- aspx 还实现了 ~IRequiresSessionState~ 接口，因此可以在 aspx 中自由使用 Session
- 在父类 Page 中，定义了控件加载的逻辑和页面渲染的逻辑
- 在父类 Page 中，初始化了很多属性和方法，可以直接使用
- 因此，掌握 Page 类的​*生命周期*和 Page 的基本方法属性非常重要

** Page 的生命周期

[[file:img/oimg_20220928_005325.png]]

PreInit:
#+begin_src csharp
  protected void Page_PreInit(object sender, EventArgs e)
  {
      // 1. 通过检查 IsPostBack 来确定页面是否是第一次被加载
      // 2. 创建(或重建)服务器控件
      // 3. 设置母版 (Master)
      // 4. 设置主题 (Theme)
      // 注意: 如果页面是 postback 那么控件的值还没有被恢复，因此你在这个阶段设置的控件值也许会被覆盖
  }
#+end_src

Init:
#+begin_src csharp
  protected void Page_Init(object sender, EventArgs e)
  {
      // 1. 这个事件是在所有控件都被初始化之后被触发的
      // 2. 为每个控件设置 UniqueID，并且应用皮肤
      // 3. 可以使用这个事件来读取或初始化控件的属性（！！！）
      // 4. 在控件树中，Init 事件是由内而外的顺序触发的
  }
#+end_src

InitComplete:
#+begin_src csharp
  protected void Page_InitComplete(object sender, EventArgs e)
  {
      // 1. 在这个阶段，viewstate 值还没有被加载。
      //    因此您可以使用此事件对视图状态进行更改，以确保在下一次 postback 后保留这些更改
      // 2. 这个事件是被 Page 对象触发的
      // 3. 如果需要所有初始化工作完成才能执行的任务，可以写在这里
  }
#+end_src

OnPreLoad:
#+begin_src csharp
  protected void OnPreLoad(object sender, EventArgs e)
  {
      // 是在 Page 对象已经加载了 ViewState 中的值、并加载完成所有控件、并通过 request 参数处理完 postback 数据之后，才触发的
  }
#+end_src

Load:
#+begin_src csharp
  protected void Page_Load(object sender, EventArgs e)
  {
      // 1. Page 对象会执行 Page 上面的 OnLoad 方法，然后递归地执行子控件的 OnLoad 方法
      // 2. 这是在生命周期中，第一个所有的值都被完全恢复了的阶段
      // 3. 绝大多数情况下，可以通过检查 IsPostBack 的值来避免不必要的重置状态
      // 4. 在这里，适合进行输入验证
      // 5. 在这里，适合动态创建、添加组件
      // 6. 在这里，适合调整控件的属性，适合创建数据库连接
  }
#+end_src

控件上的 PostBack 事件:
#+begin_src csharp
  protected void Button1_Click(object sender, EventArgs e)
  {
      // 1. ASP.NET 现在会调用所有在 Page 或子控件上的能导致 PostBack 的事件
      // 2. 使用这些事件，可以处理比如 Button 点击、TextBox 的文本变动等
  }
#+end_src

LoadComplete:
#+begin_src csharp
  protected void Page_LoadComplete(object sender, EventArgs e)
  {
      // 1. 在事件处理阶段的最后被触发的
      // 2. 这里适合所有的其他控件都被完全加载之后的任务
  }
#+end_src

OnPreRender:
#+begin_src csharp
  protected void OnPreRender(object sender, EventArgs e)
  {
      // 1. 在所有的对象都已经完全准备好的情况下触发的
      // 2. 先是 Page 上的 OnPreRender 被执行，然后递归执行子控件上的 OnPreRender
      // 3. 允许对页面或其控件进行最终更改
      // 4. 这个事件发生在保存 ViewState 之前，所以在这里做的任何修改都将被保存
      // 5. 设置了 DataSourceID 属性的每个数据绑定控件都调用其 DataBind 方法
      // 6. 这里适合用来对 Page 或控件进行最后的调整
  }
#+end_src

OnSaveStateComplete:
#+begin_src csharp
  protected void OnSaveStateComplete(object sender, EventArgs e)
  {
      // 1. 在页面和控件的 ViewState 已经被保存之后触发
      // 2. 在这里对页面或控件的修改，会被忽略掉
      // 3. 这里适合不想改变 ViewState 的一些善后工作
  }
#+end_src

Render-Method:
- Render 方法存在于 Page 对象和其子控件中
- 这个阶段，其实就是 ASP.NET 拼接 html 字符串，响应给用户的过程

Unload:
#+begin_src csharp
  protected void Page_Unload(object sender, EventArgs e)
  {
      // 1. 这个方法用来进行清理工作
      // 2. 在这个阶段，所有工作都已经完成，可以放心释放任何资源，包括 Page 对象
      // 3. 在这里，不能使用 Response.Write 输出内容，否则会报错
  }
#+end_src

参考: https://www.c-sharpcorner.com/UploadFile/8911c4/page-life-cycle-with-examples-in-Asp-Net/

** Page 的内置对象

所谓的内置对象，是指在 Page 类中被初始化，从而在 aspx 中能直接使用的对象。

#+begin_src html
  <%=Request["id"] %>
  <%=Request.QueryString["id"] %>
  <%=Request.Form["id"] %>
  <%=Request.Params["id"] %>
  <%=Request.Files["id"] %>
  <%=Request.UserAgent %>
  <%=Request.Headers["location"] %>

  <%=ViewState["kkkkk"] %>
  <% ViewState["kkkkk"] = 333; %>

  <%=Request.Cookies["Asp_Net.SessionId"] %>
  <%=Response.Cookies["ssss"] %>
  <%=Session["ksdkfj"] %>

  <% Application["网站url"] = "xxxx"; %>
  <%=Application["总共访问的数目"] %>
  <p>访问次数: <%= new Random().Next() %></p>

  <%=Server.MapPath("/UploadedFiles") %>
  <% Server.Transfer("Logon.aspx", true); %>
#+end_src

Code Action Task:
#+begin_example
----------------------    -------
| .                  |    | 验证 |
----------------------    -------

如果输入的内容长度小于5，下面用红色的字，提示:
: 您输入的内容不合格，请重新再填！
然后情况输入框，将光标 focus 到 input 框。

如果输入的内容合格，下面用绿色的字提示：
: 恭喜您，验证通过。
然后，将输入框变成只读状态。
#+end_example

#+HTML: <details><summary>参考答案</summary><br />

标注着 runat=server 的控件上的状态，
在每次请求的时候，都会被通过 _ViewState 的方式自动传递着。

#+begin_src html
  <p>
      <asp:TextBox ID="tb1" runat="server" />
      <asp:Button ID="bt1" runat="server" Text="验证" OnClick="bt1_Click" />
  </p>
  <p>
      <asp:Label ID="lb1" runat="server" />
  </p>
#+end_src

#+begin_src csharp
  protected void bt1_Click(object sender, EventArgs e)
  {
      if (tb1.Text.Length < 5)
      {
          lb1.Text = "您输入的内容不合格，请重填。";
          lb1.ForeColor = System.Drawing.Color.Red;
          tb1.Text = String.Empty;
          tb1.Focus();
      }
      else
      {
          lb1.Text = "恭喜您，验证通过";
          lb1.ForeColor = System.Drawing.Color.Green;
          tb1.ReadOnly = true;
          bt1.Enabled = false;
      }
  }
#+end_src
#+HTML: </details><br/>

Code Action Task:
#+begin_example
在页面中，显示:
: 这是本页面在 Page 生命中，被访问的第 N 次。

这个例子用来理解如何使用 ViewState 对象。
#+end_example

#+HTML: <details><summary>参考答案</summary><br />

第一种方案，借助 ~asp:HiddenField~ 控件，曲线救国。
#+begin_src html
  <asp:HiddenField ID="hf1" Value="0" runat="server" />
  <p>
      这是本页面在 Page 生命中，被访问的第 <asp:Label ID="sd" Text="<%# hf1.Value %>" runat="server"/> 次。
  </p>
#+end_src
#+begin_src csharp
  protected void Page_Load(object sender, EventArgs e)
  {
      hf1.Value = (int.Parse(hf1.Value) + 1).ToString();
      sd.DataBind();
  }
#+end_src

第二种方案，使用 ViewState 对象，即手动模式。
#+begin_src html
  <p>
      这是本页面在 Page 生命中，被访问的第 <%= VisitCount %> 次。
  </p>
#+end_src
#+begin_src csharp
  public int VisitCount { 
      get 
      {
          return ViewState["vc"] != null ? (int)ViewState["vc"] : 0;
      }
      set
      {
          ViewState["vc"] = value;
      }
  }

  protected void Page_Load(object sender, EventArgs e)
  {
      VisitCount += 1;
  }
#+end_src

#+HTML: </details>

** 常用控件
*** GridView

https://learn.microsoft.com/zh-cn/dotnet/api/system.web.ui.webcontrols.gridview?view=netframework-4.8

最简方式:
#+begin_src html
  <asp:SqlDataSource ID="DS1" runat="server"
                     SelectCommand="select * from students"
                     ConnectionString="<%$ ConnectionStrings: mydb %>" />
  <asp:GridView DataSourceID="DS1" runat="server" />
#+end_src

编程方式的数据源:
#+begin_src csharp
  studentsGV.DataSource =
      DbHelper.DoExecuteQuery("select * from students");
  studentsGV.DataBind();
#+end_src
#+begin_src html
  <asp:GridView ID="studentsGV" runat="server" />
#+end_src

灵活定义视图格式:
#+begin_src html
  <asp:GridView ID="studentsGV" runat="server"
      ShowFooter="true"
      AutoGenerateColumns="false"
      AllowSorting="true"
      EmptyDataText="没有查询到任何学生">
      <Columns>
          <asp:BoundField DataField="name" HeaderText="姓名" SortExpression="id"/>
          <asp:BoundField DataField="homecity" />
          <asp:ButtonField ButtonType="Link" Text="dksk" />
          <asp:CommandField ShowDeleteButton="true" ShowEditButton="true" />
          <asp:TemplateField>
              <ItemTemplate>
                  <div>
                      <p><%# Eval("name") %> (<%# Eval("homecity") %>)</p>
                      <h3 style="color: red">我是谁</h3>
                      <h5 style="color: green">我就是我，不一样的烟火</h5>
                      <asp:Button ID="dddd" runat="server" Text="我是按钮" />
                  </div>
              </ItemTemplate>
              <ItemStyle BackColor="Green" />
          </asp:TemplateField>
      </Columns>
      <AlternatingRowStyle BackColor="LightBlue" Font-Size="XX-Large"/>
      <HeaderStyle BackColor="Gray" />
  </asp:GridView>
#+end_src

*** Repeater

专门进行数据迭代的一个控件，可以生成更高效更优雅的代码。

https://learn.microsoft.com/zh-cn/dotnet/api/system.web.ui.webcontrols.repeater?view=netframework-4.8

#+begin_src csharp
  if (!IsPostBack)
  {
      sl.DataSource = DbHelper.DoExecuteQuery("select * from students");
      sl.DataBind();
  }
#+end_src

#+begin_src html
  <asp:Repeater ID="sl" runat="server">
      <HeaderTemplate>
          <ul>
      </HeaderTemplate>
      <ItemTemplate>
          <li><%# Eval("name") %>, <%# Eval("homecity") %></li>
      </ItemTemplate>
      <FooterTemplate>
          </ul>
      </FooterTemplate>
  </asp:Repeater>
#+end_src

** 用户自定义控件

控件的主要目的，是复用。使用控件跟调用方法很类似，只不过方法的核心是逻辑，控件的核心是视图。

自定义控件的后缀名为 ascx，用 <%@ Control> 作为标记。以 MyLogin.ascx 为例:
#+begin_src html
  <%@ Control Language="C#" AutoEventWireup="true"
      CodeBehind="MyLogin.ascx.cs"
      Inherits="StudentManageSystem_WF.MyLogin" %>

  <div>
      <asp:TextBox ID="username" runat="server" />
      <asp:TextBox ID="TextBox1" runat="server" />
      <asp:Button ID="skdfjskdjf" runat="server" Text="denglu" />
  </div>
#+end_src
#+begin_src csharp
  public partial class MyLogin : System.Web.UI.UserControl
  {
      public string DefaultUsername { get; set; }

      protected void Page_Load(object sender, EventArgs e)
      {
          if (!IsPostBack)
          {
              username.Text = DefaultUsername;
          }
      }
  }
#+end_src

要使用控件，需要通过 <%@ Register > 对控件进行注册:
#+begin_src html
  <%@ Register Src="~/MyLogin.ascx" TagName="MyLogin" TagPrefix="fl" %>
  <p>
    <fl:MyLogin runat="server" DefaultUsername="xxx" />
  </p>
#+end_src

** 其他
*** 路由 (Route)

#+begin_src csharp
  RouteTable.Routes.MapPageRoute("hello", "hello", "~/Students1.aspx");
  RouteTable.Routes.EnableFriendlyUrls(
      new FriendlyUrlSettings()
      {
          AutoRedirectMode = RedirectMode.Permanent
      }
  );
#+end_src

*** 捆绑 (Bundle)

: 让 css/js (1) 变少 (2) 变小

配置:
#+begin_src csharp
  BundleTable.Bundles.Add(new ScriptBundle("~/bundles/MsAjaxJs").Include(
      "~/Scripts/WebForms/MsAjax/MicrosoftAjax.js",
      "~/Scripts/WebForms/MsAjax/MicrosoftAjaxApplicationServices.js",
      "~/Scripts/WebForms/MsAjax/MicrosoftAjaxTimer.js",
      "~/Scripts/WebForms/MsAjax/MicrosoftAjaxWebForms.js"));
#+end_src

使用:
#+begin_src html
  <asp:PlaceHolder runat="server">
      <%: Scripts.Render("~/bundles/modernizr") %>
  </asp:PlaceHolder>
  <webopt:bundlereference runat="server" path="~/Content/css" />
#+end_src

*** 网站 Logo (favicon.ico)

放在网站的根目录。

*** IHttpHandler.IsReusable

重用。

* ASP.NET MVC
** MVC

ASP.NET MVC:
- 基于 MVC 概念:
  + Model (模型)
  + View  (视图), 默认使用 Razor 作为页面的模板引擎
  + Controller (控制器)
- 约定大于配置 (CoC, Convention Over Configuration) 的理念

项目文件夹:
- Controller
- View
- Model

** Lifecycle

[[file:img/mvc-lifecycle.png]]

首先，在 =UrlRoutingModule= 中获取路由数据，并找到要处理的 MvcHandler:
#+begin_src csharp
  // 通过 RouteTable 获取路由数据
  RouteData routeData = this.RouteCollection.GetRouteData(context);
  // 使用 MvcHandler 处理接下来的请求
  IRouteHandler routeHandler = routeData.RouteHandler;
  IHttpHandler httpHandler = routeHandler.GetHttpHandler(requestContext);
  context.RemapHandler(httpHandler);
#+end_src
  
其次，在 =MvcHandler= 中，创建对应的 Controller 对象，并调用其 Execute 方法:
#+begin_src csharp
  // 创建 Controller 对象
  this.ProcessRequestInit(httpContext, out controller, out controllerFactory);
  // 调用 Controller 中的 Execute 方法
  controller.Execute(this.RequestContext);
#+end_src

然后，通过 =Controller.InvokeAction= 调用对应的 Action 方法:
#+begin_src csharp
  // 获取 Action 上所有过滤器
  FilterInfo filters = this.GetFilters(controllerContext, actionDescriptor);
  try
  {
      // 执行其中的 Authentication (认证) 过滤器
      AuthenticationContext authenticationContext = this.InvokeAuthenticationFilters(controllerContext, filters.AuthenticationFilters, actionDescriptor);
      // 执行其中的 Authorization (授权) 过滤器 
      AuthorizationContext authorizationContext = this.InvokeAuthorizationFilters(controllerContext, filters.AuthorizationFilters, actionDescriptor);
      // 获取并绑定请求参数
      IDictionary<string, object> parameterValues = this.GetParameterValues(controllerContext, actionDescriptor);
      // (执行 ActionFilter.OnActionExecuting 然后) 执行 Action 方法！
      ActionExecutedContext actionExecutedContext = this.InvokeActionMethodWithFilters(controllerContext, filters.ActionFilters, actionDescriptor, parameterValues);
      // 执行后置过滤器
      AuthenticationChallengeContext authenticationChallengeContext3 = this.InvokeAuthenticationFiltersChallenge(controllerContext, filters.AuthenticationFilters, actionDescriptor, actionExecutedContext.Result);
      this.InvokeActionResultWithFilters(controllerContext, filters.ResultFilters, authenticationChallengeContext3.Result ?? actionExecutedContext.Result);
  }
  catch
  {
      // 执行异常过滤器
      ExceptionContext exceptionContext = this.InvokeExceptionFilters(controllerContext, filters.ExceptionFilters, exception);
  }
#+end_src

最后，通过 ViewEngines 选择合适的 IViewEngine，并根据结果类型调用响应的 =IView.Render= 方法，完成渲染:
#+begin_src csharp
  /// 可以定义并使用自己的 ViewEngine
  protected void Application_Start()
  {
      //移除所有的View引擎包括Webform和Razor
      ViewEngines.Engines.Clear();
    
      //注册你自己的View引擎
      ViewEngines.Engines.Add(new CustomViewEngine());
  }
#+end_src

参考: https://www.cnblogs.com/PatrickLiu/p/15175388.html

** Action

- Action 是 Controller 里面用来处理请求产生响应的一个方法
- 返回值是一个普通的 string/int 等或者是一个 ActionResult

ActionResult:
- Content() 方法用来返回一个 ContentResult 对象，即返回字符串本身
- View() 方法用来返回一个 ViewResult，利用 razor 引擎生成 html 字符串
- Json() 方法用来返回一个 JsonResult 对象，即将数据序列化
- File() 方法用来返回一个 FileResult 对象，用来处理文件的下载
- HttpNotFound, new HttpNotFoundResult, new HttpStatusCodeResult(505)
- Redirect/RedirectToAction/RedirectToRoute

传递数据的方式:
- ViewBag
- ViewData
- Model

** Razor

- Html 代码跟 CSharp 代码混编
- 分解符: 遇到 @ 就是 csharp, 遇到 < 就是 html 代码
- 常用指令: @model, @functions 等
- 常用的类: Html/Ajax/Url/Model/ViewBag/ViewData/Layout
- Q: ViewBag vs ViewData 有什么区别?

** Binding/Validation

- 参数是自动绑定的，注意 [Bind] 的使用
- 验证，推荐使用的是 Model 验证方式:
  1. 定义或者选择适当的 =ValidationAttribute=
  2. 放置到 Model 的相关属性上
  3. 在 Action 中使用 =ModelState.IsValid= 来判断有没有验证的错误
  4. 在 Razor 中使用 =@Html.ValidationSummary/ValidationMessageFor= 对错误信息进行输出
- 其他方式，比如手动验证:
  #+begin_src csharp
    if (student.Name.Length > 2)
    {
        ModelState.AddModelError("Name", new Exception("太长"));
    }
  #+end_src

内置的很多 Attribute 在 System.ComponentModel.DataAnnotations 包下面:
- Required
- StringLength
- Range
- RegularExpression

自定义验证 Attribute:
#+begin_src csharp
  public class MyRequiredAttribute : ValidationAttribute
  {
      public override bool IsValid(object value)
      {
      }
  }
#+end_src

** Filter

接口、方法:
- IAuthenticationFilter/IAuthorizationFilter (AuthorizeAttribute)
- IActionFilter (ActionFilterAttribute)
- IResultFilter (ActionFilterAttribute)
- IExceptionFilter (HandleErrorAttribute)

* ASP.NET WebAPI
** JSON

JavaScript Object Notation.

来源于 Javascript 的对象语法:
#+begin_src javascript
  var i = 1;
  var j = "hello";
  var arr = [2, 3, 4];
  var obj = {
      "a": 1,
      "b": 2,
      "c": 3
  };
  var students = [
      {
          id: 1,
          name: 222,
          age: 333
      },
      {
          id: 2,
          name: 222,
          age: 333
      },
      {
          id: 3,
          name: 222,
          age: 333
      }
  ];
#+end_src

使用 JS 在 Json 字符串和对象之间进行转换:
#+begin_src javascript
  var s1 = [{id: 1, name: 'zs'}, {id:2, name:'ls'}];
  var stringS1 = JSON.stringify(s1);

  var s2 = '[{"id": 3333, "name": "lisi"},{"id": 444, "name": "wangwu"}]';
  var jsonS2 = JSON.parse(s2);
#+end_src

使用 CSharp 在 Json 字符串和 C# 对象之间进行转换:
#+begin_src csharp
  var students = new List<Student>
  {
      new Student { Id = "1", Name = "zhangsan" },
      new Student { Id = "2", Name = "lisi" }
  };
  string s1 = JsonConvert.SerializeObject(students);
  List<Student> s2 = JsonConvert.DeserializeObject<List<Student>>(s1);
  s2.Add(new Student { Id = "3", Name = "ww" });
  return JsonConvert.SerializeObject(s2);
#+end_src

** WebApiConfig.cs

可以在这里配置 WebAPI 相关的选项。

比如，设置返回数据格式:
#+begin_src csharp
  // 让默认情况下不返回 xml 结果的数据，而是 JSON 的
  config.Formatters.XmlFormatter.SupportedMediaTypes.Clear();
  // 对 JSON 数据使用混合大小写
  config.Formatters.JsonFormatter.SerializerSettings.ContractResolver = new CamelCasePropertyNamesContractResolver();
  // 添加自定义的 Formatter
  config.Formatters.Add(new YourFormatter());
#+end_src

比如，设置路由格式:
#+begin_src csharp
  config.Routes.MapHttpRoute(
      name: "DefaultApi",
      routeTemplate: "api/{controller}/{id}",
      defaults: new { id = RouteParameter.Optional }
  );
#+end_src

** Router

默认的路由规则是在 WebApiConfig.cs 中定义的:
: api/{controller}/{id}

因此:
- 请求 =GET /abc= 对应 AbcController 的 =GetXxx= 方法
- 请求 =PUT /abc/3= 对应 AbcController 的 =PutXxx(id)= 方法
- 默认情况是通过方法名的前缀判断 HTTP METHOD 的。可以通过在 Action 上添加 =[HttpGet]= 等特性显式指定
- 可以将 =[Route("xxx")]= 添加到 Controller 或 Action 上，单独设置独立的路由

** Action

方法名字 vs 请求方法:
- 按照 CoC 的设计思想，GetBook 默认将处理 GET 请求，DeleteBook 默认将处理 Delete 请求，如此类推
- 可以通过在 Action 上添加 [HttpXxx] 特性，显式指定请求方法

返回类型:
| 返回类型            | Web API 如何创建响应                                                     |
|---------------------+--------------------------------------------------------------------------|
| void                | 返回空 204 (无内容)                                                      |
| HttpResponseMessage | 直接转换为 HTTP 响应消息。                                               |
| IHttpActionResult   | 调用 ExecuteAsync 以创建 HttpResponseMessage，然后转换为 HTTP 响应消息。 |
| 其他类型的          | 将序列化的返回值写入响应正文;返回 200 (OK) 。                            |

示例:
#+begin_src csharp
  // 将会自动序列化为 JSON 返回
  public Book GetBook(int id)
  {
      return db.Books.Find(id);
  }

  // 灵活进行不同的响应
  public IHttpActionResult GetBook(int id)
  {
      Book book = db.Books.Find(id);
      return book == null ? NotFound() : Ok(book);
  }
#+end_src

** Help

在 Areas 下面存在一个 HelpPage 的域，里面实现了展示当前所有 API 文档的功能。

可以通过 =https://localhost:23232/Help= 的方式进行访问。

https://learn.microsoft.com/zh-cn/aspnet/web-api/overview/getting-started-with-aspnet-web-api/creating-api-help-pages

* .NET Core
** 跨平台开发

- 推出了跨平台的 VSCode (lsp, Language Server Prototol)
- Windows 下面安装环境 (https://learn.microsoft.com/zh-cn/dotnet/core/install/windows?tabs=net60)
- NuGet (https://www.nuget.org/)
- dotnet 命令行工具

** dotnet 命令行工具

https://learn.microsoft.com/zh-cn/dotnet/core/tools/dotnet

创建项目:
#+begin_src shell
  dotnet new --list  # 列出所有的项目模板
  dotnet new console
  dotnet new console -o first
  dotnet new console --output first
  dotnet new console -o "second console project"

  dotnet new mvc
  dotnet new webapi
#+end_src

构建项目:
#+begin_src shell
  dotnet build
#+end_src

运行构建完成的 dll 可执行文件:
#+begin_src shell
  dotnet exec myapp.dll
  dotnet myapp.dll
#+end_src

为项目添加项目或 NuGet 依赖：
#+begin_src shell
  dotnet add reference lib1/lib1.csproj lib2/lib2.csproj
  dotnet add package Microsoft.EntityFrameworkCore
#+end_src

其他命令:
#+begin_src shell
  dotnet restore
  dotnet run
  dotnet watch run
  dotnet clean
  dotnet publish
  dotnet test
#+end_src


** C# 语法拾遗

语法糖 (Syntax Sugar), 用来锦上添花的。

*** NULL

正则表达式

- 可空类型 (decimal?), 为值类型增加一个 null 选项。用于区分默认值跟未赋值
- =A?.X=, 其实是 =A == null ? null : A.X= 的语法糖。主要用于避免 NullPointerException
  
?. 语法糖:
#+begin_src csharp
  string name;
  if (p == null)
  {
      name = null;
  }
  else
  {
      name = p.Name;
  }
  decimal? price = (p == null ? null : p.Price);
  decimal? price = p?.Price;
  string rname = p?.Related?.Name;
  results.Add($"Name: {p?.Name}, Price: {p?.Price}, Related: {rname}");


  // 使用了 ?. 语法糖的写法
  string rname = p?.Related?.Name;

  // 不使用语法糖的实现
  if (p != null && p.Related != null)
  {
      rname = p.Related.Name;
  }
  else
  {
      rname = null;
  }
#+end_src

?? 语法糖:
#+begin_src csharp
  string author = db.Authors.Find(3);
  // ....
  if (author == null)
  {
      author = "未名";
  }
  Console.WriteLine($"{author}");

  // 简化为
  string author = db.Authors.Find(3);
  // ....
  author ?? "未名"
#+end_src

?. 和 ?? 混合使用:
#+begin_src csharp
  string name = p.Name;
  decimal? price = p.Price;
  string relatedName = p.Related.Name;
  
  string name = p?.Name ?? "<No Name>";
  decimal? price = p?.Price ?? 9999;
  string relatedName = p?.Related?.Name ?? "<none>";
#+end_src

*** 自动属性

#+begin_src csharp
  // DRY
  public class Suibian
  {
      private string name;
      public string Name
      {
          get
          {
              return name;
          }
          set
          {
              name = value;
          }
      }

      // 多谢编译器哥哥
      public decimal? Price { get; set; }
      public Related Suibian { get; private set; }
      public decimal? Price { get; set; } = 9999M;
      public decimal? Price { get; } = 9999M;

      public decimal? Price { get { return 33; }};
      public decimal? Price => 33;   // 属性定义
      public decimal? _price = 33;   // 字段定义
  }

#+end_src

*** 插值字符串

#+begin_src csharp
  string info = "hello" + name + ", wo men yao dao " + place + "play";
  // StringBuilder sb = new(); sb.Append.....;
  string info = string.Format("hello {0}, wo men yao dao {1} play", name, place);
  string info = $"hello {name}, wo men yao dao {place} play";
#+end_src

*** 初始化器

对象初始化:
#+begin_src csharp
  Factory f = new Factory();
  f.Name = "fsk";
  Product p = new Product();
  p.Name = "hello";
  p.Price = 333;
  f.Weixin = "dkfjdkfj";
  p.Weixin = "ksjdfksdjkfjdsk";

  // 简化
  Factory f = new Factory ()
  {
      Name = "fsk", Weixin = "bzd"
  };
  Product p = new Product
  {
      Name = "hello", Weixin = "kkk", Price = 333
  };
  var p = new Product
  {
      Name = "hello", Weixin = "kkk", Price = 333
  };
#+end_src

数组初始化:
#+begin_src csharp
  string[] names = new string[]
  {
      "aaa", "bbb", "ccc"
  };
#+end_src

List 初始化:
#+begin_src csharp
  List<string> r1 = new List<string>();
  r1.Add("aaa");
  r1.Add("bbb");
  r1.Add("ccc");
  List<string> r2 = new List<string>();
  List<string> r3 = new();
  var r4 = new List<string>();
  var r5 = new List<string>()
  {
      "aaa", "bbb", "ccc"
  };
#+end_src

Dictionary 初始化:
#+begin_src csharp
  Dictionary<string, int> scores1 = new Dictionary<string, int>();
  scores1["zs"] = 33;
  scores1["ls"] = 66;
  Dictionary<string, int> scores2 = new ();
  var scores3 = new Dictionary<string, int>();
  var scores4 = new Dictionary<string, int>
  {
      {"zs", 33}, {"ls", 66}
  };
  var scores5 = new Dictionary<string, int>
  {
      ["zs"] = 33,
      ["ls"] = 66 
  };
#+end_src

*** 模式匹配 (Patter-Match)

模式匹配是函数型语言 (F#, Haskell) 的标配，微软将其引入了面向对象的 C# 中。

switch -> case when:
#+begin_src csharp
  // 原写法，使用 if/else
  object[] arr = new object[] { 333, "hello", 444M, 1M, 223f };
  decimal total = 0;
  foreach (object item in arr)
  {
      if (item is decimal d)
      {
          total += d;
      }
      else if (item is int i)
      {
          total += i;
      }
  }

  // 原 switch/case
  string aaa = "dkfjd";
  switch (aaa)
  {
      case "hello":
          System.Console.WriteLine("dkfj");
          break;
      case "world":
          System.Console.WriteLine("dkkfk");
          break;
  }

  // 使用 switch...case...when 语法进行模式匹配
  object[] arr = new object[] { 333, "hello", 444M, 1M, 223f };
  decimal total = 0;
  foreach (object item in arr)
  {
      switch (item)
      {
          case decimal d:
              total += d;
              break;
          case int i when i > 3:
              total += i;
              break;
      }
  }
#+end_src

*** 扩展方法

#+begin_src csharp
  public static class MyKuozhanMethod
  {
      public static void Eat(this IALive d, string food)
      {
          System.Console.WriteLine($"{food} zhenhaochi");
      }
  }

  public interface IALive { }
  public class Dog : IALive { }
  public class Cat : IALive { }
  public class Person : IALive { }

  // test
  new Dog().Eat("xiang");
  new Cat().Eat("ksdfksjd");
#+end_src

* ASP.NET Core MVC
** Summary

- IActionResult
- asp-for
