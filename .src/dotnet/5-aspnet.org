#+TITLE: ASP.NET


* 单机 到 CS 到 BS

要注意，.NET 跟 C# 不是一样的概念：
:    编译器                  运行
: C#   ->   中间码(IL) ->   (.NET)  -> 机器码
: F#
: VB
: JS
: Java
: 
: .java -> .class -> (JVM) -> 机器码
: kotlin
: groovy
: clojue
: scala

经典、传统软件 (桌面软件):
- 语言: C/C++/C#/Java/OC/Swift
- 技术: Winform/WPF/UWP/MaUI Qt/GTK

单机软件不符合应用场景，多机协助成了最大需求。
最终，出现了 CS (Client-Server) 架构。
- 多机通信使用 Socket，但是 Socket 需要处理太多细节，比较麻烦
- 都要从 0 开始构建底层界面
- BS 能干的事情，CS *一定* 可以做到而且可以干的更好，但是 CS 要花费更高的 *成本*
- CS 能干的事情，BS 不一定能做到。CS 的客户端可以对系统进行完全的控制，它可以实现浏览器无法实现的很多行为
- BS 架构，通过放弃了一些东西，成功降低了各种成本:
  + 学习成本低
  + 开发成本低
  + 使用成本低

#+begin_src html
  <h1>标题</h1>
  <form action="xxx">
    <input type="submit" value="点我发送" />
  </form>
#+end_src

任务: 
- 什么是 CS 架构，什么是 BS 架构?
- CS 架构跟 BS 架构相比，各有什么优劣?
- 整理资料，了解浏览器的发展历史

360/....很多野生浏览器:
- 当时 IE 你不能不用，而且多个版本之间还有差别。IE6
- 当时先进生产力的代表是 Firefox, Chrome, Opera 等更加贴近标准的浏览器
- 双(多)核浏览器+兼容


* ASP -> ASP.NET -> ASP.NET Core

大致分为三个阶段:
1. 1996 年左右，ASP (Active Server Page), 使用的开发语言是 VB
2. 2002 年左右，随着 .NET 平台出现，推出了 ASP.NET 技术
3. 2015 年左右，微软开始推出跨平台的 .NET，称作 .NET Core

* ASP.NET (Framework)

Pipeline (管道/管线) 模型:
- 最核心的接口: ~IHttpHandler/IHttpHandlerFactory~, ~IHttpModule~
- 最核心的配置文件: Web.config
- 比较重要的类: HttpApplication, HttpContext

Pipeline 中标准的 19 个事件:
[[file:img/oimg_20220920_070127.png]]
Global.asax:
- Application_Start/End
- Session_Start/End
- Application_BeginRequest/AuthenticateRequest/Error

部署:
- 环境: Windows + SqlServer + IIS
- IIS 是缩写，全称 Internet Information Services (互联网信息服务 ), 是由微软公司提供的基于运行 .NET 的互联网基本服务。
- 步骤: 
  1. 开发项目，通过【发布】导出要部署的项目文件夹
  2. 在服务器上安 Windows 操作系统
  3. 在 Windows 中安装 SqlServer 数据库
  4. 在 Windows 中启用 IIS 服务器
  5. 在 IIS 管理器中，为项目文件夹创建新的【网站】
  6. 注意整个过程中的【权限】和【防火墙】问题


* ASP.NET Webform
** aspx 文件

首先，可以将 aspx 文件看做一个加强版的 html 文件，所以，它完全接受 html 语法。

因此创建一个 Hello.aspx 文件，内容如下:
#+begin_src html
  <html>
    <h1>我是 Hello.aspx 文件，所有的 html 代码在这里都会被原样返回给浏览器</h1>
    <p> 其他的或简单或复杂的 html/js/css 代码 </p>
  </html>
#+end_src

运行项目，可以通过 ~https://localhost:port/Hello.aspx~ 访问这个页面。浏览器中查看源代码可以看到内容跟上述一致。

接下来，aspx 接受行内表达式语法。这种语法来源于之前的 asp 时代，是在 html 内嵌 C#/VB 代码的一种方式 ([[https://learn.microsoft.com/en-us/troubleshoot/developer/webapps/aspnet/development/inline-expressions][官方链接]])。
#+begin_src html
  <html>
    <h1>我是 Hello.aspx 文件，所有的 html 代码在这里都会被原样返回给浏览器</h1>
    <p> 其他的或简单或复杂的 html/js/css 代码 </p>
    <div>
      <% Response.Write("通过行内表达式，可以在文件中嵌入 C# 代码了！"); %>
      <% Response.Write(Request.UserAgent); %>
      <%
        string a = "可以写很多代码，在这里"; 
        string c = "现在，定义一个变量，后面使用";
      %>

      <% Response.Write(c); %>
      <%-- 我是一个注释: 下面的一行代码，是上面代码的语法糖 --%>
      <%= c >

      <%= "<div>你好</div>" %>
      <%-- 使用 %: 进行自动格式化输出 --%>
      <% Response.Write(HttpUtility.HtmlEncode("<div>你好</div>")); %>
      <%= HttpUtility.HtmlEncode("<div>你好</div>") %>
      <%: "<div>你好</div>" %>

      <%# Button1.Controls %>
      <%#: Button1.Controls %>
    </div>
  </html>
#+end_src

微软说，时代变了，行内表达式容易导致逻辑跟页面混淆，不便于维护和复用。亲，建议使用控件。
控件的使用方法，跟 Winform 中实在太像了:
#+begin_src html
  <html>
    <form id="form1" runat="server">
       <asp:Calendar ID="Calendar1" runat="server"></asp:Calendar>
       <asp:Button ID="Button1" runat="server" OnClick="Button1_Click" Text="Button" />
    </form>
  </html>
#+end_src

如果是方法等大段的 C# 代码，可以写在 script runat server 里面:
#+begin_src html
  <html>
    <script runat="server">
        public string MyName = "真难";
        public string HelloWorld() { return "HelloWorld"; }
        public string MyCalender() { return "<div>我是一个巨复杂的日历</div>"; }
        protected void Button1_Click(object sender, EventArgs e) { }
    </script>

    <%= MyCalender() %>
    <asp:Calendar ID="Calendar1" runat="server"></asp:Calendar>
  </html>
#+end_src

但是上述 C# 代码写在 aspx 文件里，开发成本和维护成本都比较高，所以能不能有一种机制将其​*分离*​出去?
有的，有的。使用页面指令，指定外部 csharp 文件即可:
#+begin_src html
  <%@ Page Language="C#" AutoEventWireup="true" CodeBehind="Balala.cs" Inherits="WebApplication2.Balala" %>
#+end_src

于是，就可以创建文件 Balala.cs 在里面专注于数据和业务逻辑，之后让 aspx 专注于页面展现了（模型与视图分离的思想）。

这个 Balala.cs 需要写成类似这个样子:
#+begin_src csharp
  namespace WebApplication2
  {
      public partial class Balala : Page
      {
          public string MyName = "真难";
          public string HelloWorld()
          {
              return "HelloWorld";
          }
          public string MyCalender()
          {
              return "<div>我是一个巨复杂的日历</div>";
          }
          protected void Button1_Click(object sender, EventArgs e)
          {
          }
      }
  }
#+end_src

通过以上操作，一个完整的 Web 窗体就有了。

另外，不同的页面往往在整体的布局存在很多相似之处，不同页面存在大量雷同代码。
为了简化在 aspx 中构建页面，可以通过母版的方式，将整体的页面布局代码分离到外面 (挖坑-填坑)，
达到共用布局的目的。

方法很简单，首先，要创建一个母版文件。它跟 aspx 很像，只是文件的后缀和页面指令不同。比如，创建一个 yyy.Master 母版:
#+begin_src html
  <%@ Master Language="C#" %>

  <html>
  <head>
      <title></title>
      <asp:ContentPlaceHolder ID="head" runat="server" />
  </head>
  <body>
      <aside>
          菜单
      </aside>
      <div class="main">
          <asp:ContentPlaceHolder ID="main" runat="server" />
      </div>
  </body>
  </html>
#+end_src

通过使用 ~asp:ContentPlaceHolder~ 挖坑。使用这个母版的 aspx 文件，只需要用 ~asp:Content~ 填坑即可。

#+begin_src html
  <%@ Page Language="C#" AutoEventWireup="true"
      MasterPageFile="~/yyy.Master"
      CodeBehind="WebForm2.aspx.cs" Inherits="WebApplication2.WebForm2" %>

  <asp:Content runat="server" ContentPlaceHolderID="head">
      <style>
          .main {
              background: lightyellow;
              height: 200px;
          }
      </style>
  </asp:Content>

  <asp:Content runat="server" ContentPlaceHolderID="main">
      <div style="color: red;">
          我是另外的一个页面
      </div>
  </asp:Content>
#+end_src

就这样，就实现了页面布局的可重复使用。编码可以更灵活了。

** Page 类

你 (Browser) 请求 http://localhost:893232/Hello.aspx 到我 (IIS):
- 首先，查找 aspx 有没有对应的编译文件。如果有，执行之；否则，先编译，后执行之
- aspx 会被动态转换为相应的 csharp 文件，之后会被编译进 dll 中 (HttpRuntime.CodegenDir)
- aspx 文件实质是 ~Page~ 的一个子类，它实现了 ~IHttpHandler~ 接口
- aspx 还实现了 ~IRequiresSessionState~ 接口，因此可以在 aspx 中自由使用 Session
- 在父类 Page 中，定义了控件加载的逻辑和页面渲染的逻辑
- 在父类 Page 中，初始化了很多属性和方法，可以直接使用
- 因此，掌握 Page 类的​*生命周期*和 Page 的基本方法属性非常重要

Page 类事件：
[[file:img/oimg_20220928_005325.png]]


* ASP.NET MVC

MVC:
- Model (模型)
- View  (视图)
- Controller (控制器)
