#+TITLE: Database

* Overview
:PROPERTIES:
:layout: Center
:END:

#+ATTR_HTML: :type Heading :fontFamily kaiti
使用 .NET 操作数据库

#+ATTR_HTML: :theme {{ fontSizes: { text: "50px" }}} :style {{ margin: "1em 2em" }}
- ADO.NET
- Entity Framework
- Entity Framework Core
- Dapper/FreeSQL

* ADO.NET
:PROPERTIES:
:layout: top
:END:
** ADO.NET         <RowGrid>
*** What

ADO.NET:
- System.Data.dll
- DbConnection, DbCommand, DataReader, DataAdapter, DataSet
- SqlConnection (SqlServer)

#+SPLIT: 2

Entity Framework:

#+begin_example
  
 你 SQL 语句  ---->   SQL 服务器
            <-----


 EF  --object---> 翻译 --sql---->  SQL 服务器
     <--object--- 封装 ---data---

#+end_example

优点缺点:
1. 多了中间环节。CPU 内存
2. 翻译质量怎么样?

ChatGPT

*** Code

首先，添加依赖:
#+begin_src shell
  dotnet add package System.Data.SqlClient # SqlServer
  dotnet add package MySql.Data            # MySQL
  dotnet add package Microsoft.Data.Sqlite # SQLite
#+end_src

其次，直接使用相关对象完成数据库操作:
#+begin_src csharp

  // Connection 对象，通道
  using var conn = new SqlConnection("lianjiezifuchuan");
  conn.Open();

  // Command 对象，用来描述我们的任务
  var cmd = new SqlCommand("select * from xxx where id=@id", conn);
  cmd.Parameters.AddWithValue("id", 3);

  // 执行、发布任务
  int num = cmd.ExecuteNonQuery();      // 增删改
  var reader = cmd.ExecuteReader();     // 基于游标的对象
  var object = cmd.ExecuteScalar();     // 第一行的第一列
  new DataAdapter(cmd).Fill(dataTable); // 一次到位封装到既定对象中
#+end_src

整理总结，Sql 连接字符串的写法:
#+begin_src csharp
  "server=localhost;database=BookDB;uid=sa;pwd=sa1234";        // 用户名密码登陆
  "server=127.0.0.1;database=BookDB;integrated security=SSPI"; // Windows 用户登陆
  "server=.;database=BookDB;integrated security=SSPI";         // 使用 . 代表 localhost
  "Data Source=localhost;initial catalog=BookDB;integrated security=True;Connect Timeout=30";
#+end_src

** Procedure       <RowGrid>
*** What

存储过程:
- 什么是存储过程?
- 使用存储过程有什么优点和缺点?

#+begin_quote
存储过程是一组预编译的 SQL 语句，它可以包含数据操作语句和变量逻辑等。\\
它保存在数据库中，通过名字可以反复使用。

#+SPLIT: 2

优点:
- 效率高
- 提高系统的安全性
- 技术成本

缺点:
- 禁止使用存储过程，存储过程难以调试和扩展，更没有移植性
#+end_quote


SQL (Sequence Query Language)
:   -- 发送一句话
:   -- 回应一句话

不是标准。PLSQL/TSQL

[shengchengdingdan] -> 查询 -- 生成 -- 插入订单 -.......

C# -> shengchengdingdan

*** Code

编写存储过程:
#+begin_src sql
  -- 创建
  create procedure p_aa1 as
    create table xxx (a int, b varchar(20));
    insert into xxx values (1, 2), (2, 3), (3, 4);
    select * from xxx;
    waitfor delay '00:00:20' drop table xxx;
  GO

  -- 执行
  exec p_aa1;
  GO

  -- 删除
  drop procedure p_aa1;
  drop proc p_aa1;

  -- 修改
  alter procedure p_aa1 as
    select * from emp;
#+end_src

** 存储过程代码示例  <RowGrid>

没有参数:
#+begin_src sql
  create procedure p_aaa as select * from xxx;
  exec p_aaa;
#+end_src

带有参数:
#+begin_src sql
  create procedure
    p_aaa @name varchar(20) 
  as
    select * from xxx where name < @name;

  exec p_aaa 30;
#+end_src

带有参数，还有默认值:
#+begin_src sql
  create procedure p_aaa
    @name varchar(20) = 'Tom'
  as
    select * from xxx where name < @name;

  exec p_aaa;
  exec p_aaa 'xxx';
#+end_src

#+SPLIT: t

带 output 参数的存储过程:
#+begin_src sql
  create procedure p_aaa
    @r int output
  as
    select @r = count(*) from xxx;

  -- 调用
  declare @rrr int;
  exec p_aaa @rrr output;
#+end_src

混合各种参数:
#+begin_src sql
  create procedure p_aaa
    @n varchar(20) = 'TOM',
    @r int output
  as
    select @r = count(*) from xxx where name < @n;

  -- 调用
  declare @rrr int;
  exec p_aaa 'Cat', @rrr output;

  -- 查看返回的结果
  select @rrr;
#+end_src

** 系统存储过程

系统内置的存储过程，一般是 sp_ 开始 (system procedure):
#+begin_src sql
  exec sp_databases;
  exec sp_help;
  exec sp_helptext sp_databases;
  exec sp_helptext sp_helptext; -- 查看存储过程怎么写的

  exec sp_tables;
  exec sp_columns emp;
#+end_src

扩展出来的存储过程以 xp_ 开始 (extenstion procedure):
#+begin_src sql
  exec xp_cmdshell 'mkdir e:\hello';
  exec xp_fileexist 'e:\hello';

  -- xp_enumgroups;
  -- xp_loginconfig
  -- xp_msver
  -- xp_grantlogin;
  -- ...
#+end_src

** 使用存储过程实现报表

为 emp 生成统计数据，统计所有部门的平均工资、最小工资和最大工资，将结果保存到 tj_emp 表中。要求:
- 如果这张表不存在，那么创建
- 如果这张表存在，但是里面有数据，清空它
- 如果插入完成，在日志表 (my_log) 插入一条信息

写法示例，仅供参考:

#+ATTR_HTML: :style {{ margin: "1em" }}
#+begin_src sql
  create procedure p_tj_emp
    @lowsal int = 1000,
    @highsal int = 10000
  as
  begin
    -- 如果不存在，创建之
    if not exists (select * from sys.tables where name = 'tj_emp')
       create table tj_emp (deptno int, a float, b float, c float);
    -- 清空数据
    truncate table tj_emp;
    -- 插入新的数据
    insert into tj_emp select deptno, avg(sal) as a, max(sal) as b, min(sal) as c from emp
      where sal >= @lowsal and sal <= @highsal
      group by deptno;
    -- 记录日志
    insert into my_log (message) values ('统计完成 - ' + convert(varchar(200), getdate(), 20));
    -- 结束
    print 'hello, finished.';
  end
#+end_src

** 数据库中的其他对象 <RowGrid>

数据库中的其他对象:
- Table/Index
- View 视图，虚表
- Function 函数
- Trigger 触发器

#+ATTR_HTML: :margin 2em 0
#+begin_src sql
  -- 视图
  create view zh_works as select * from works where city = '珠海';
  select * from zh_works where sal > 2000;
  select * from works where city = '珠海' and sal > 2000;

  -- 函数，返回值
  select getdate();
  select 32000/datediff(day,'2019-08-05','2020-08-07');
  select rand() + 3333;
#+end_src

#+SPLIT: t

对于函数，一定要有返回值:
#+begin_src sql
  create function pingjungongzi (@deptno int) returns int
  as
  begin
    declare @avgsal int;
    select @avgsal = avg(sal) from emp where deptno = @deptno;
    return @avgsal;
  end;

  -- 调用刚才的函数
  select dbo.pingjungongzi(20);

  -- 另外调用方式
  declare @s int;
  exec @s = pingjungongzi 20;
#+end_src

触发器:
#+begin_src sql
  -- 触发器被自动执行
  create trigger tri_emp_insert_jiagongzi
    on emp
    after insert
  as -- inserted 表示插入的数据形成的临时表，名字就叫 inserted
    update emp set sal = sal + 100 where empno = (select mgr from inserted);

  -- 测试
  select * from emp;
  insert into emp (empno, ename, mgr, deptno, sal)
    values (999, 'ganmaoling', 7902, 10, 2000);
#+end_src

** 使用 ADO.NET 操作存储过程

首先，确保存储过程已存在:
#+begin_src sql
  create procedure [CSharp].[GetBooks] @name nvarchar(20)
     as select * from books where name = @name
#+end_src

使用 ADO.NET 的语法操作存储过程:
#+begin_src csharp
  var command = conn.CreateCommand();
  command.CommandText = "[CSharp].[GetBooks]";
  command.CommandType = CommandType.StoredProcedure;

  var p1 = command.CreateParameter();
  p1.SqlDbType = SqlDbType.NvarChar;
  p1.ParameterName = "@name";
  p1.Value = "xxx";
  command.Parameters.Add(p1);

  conn.Open();

  using var reader = command.ExecuteReader();
  while(reader.Read())
  {
      Console.WriteLine($"{(int)reader[1]}");
  }
#+end_src

** Q & A (row_number/pagination)
*** <TaskBox>

写一个 SQL 存储过程:
- 建立一个表 Books, 字段是编号、书名、价格、库存、入库日期 （如果表不存在）
- 向里面插入 6 条数据 (如果不存在数据)
- 然后查询出除了价格最高的书之外的价格最高的 3 条数据

*** <RowGrid>
:PROPERTIES:
:props: theme={t2}
:END:

分页的基本实现方式:
1. top
2. row_number 窗口函数
3. offset fetch next

#+begin_example
row_number:
- 先分区 (partition by, 如果没有，那么将整个数据集作为一个分区)
- 再基于每个分区执行排序 (order by)
- 再给每个分区的每条数据添加行号
#+end_example

返回: 所有的书籍，每种类型价格排第二的数据:
#+begin_src sql
  select * from (
    select row_number() over (partition by category order by price desc) n,
           ,* from t_books
  ) x where n = 2;
#+end_src

#+SPLIT: t

参考答案:

#+ATTR_HTML: :type ScCodePane
#+begin_src sql
  -- 数据库一般是不区分大小写的，所以最好不要使用驼峰命名
  -- 命名的时候，最好遵循一定的规范。比如存储过程 p 开始，触发器 tr/tri;
  -- 勿以善小而不为，勿以恶小而为之。从细节做起，别妥协，不要养成不好的习惯

  if exists (select * from sys.objects where name  ='p_selects_books')
      drop procedure p_selects_books   -- 风险性提醒

  go

  create procedure p_selects_books
  as
  begin
      if not exists (select * from sys.objects where name  ='t_books')
        create table t_books (
          isbn varchar(100) primary key,
          name varchar(100) not null, 
          price money not null check(price > 0),
          amount int default 0,
          category varchar(20),
          updated_at datetime default getdate()
      );

      if not exists (select top 1 * from t_books)
        insert into t_books (isbn, name, price, amount, category) values
          ('110', 'aaa', 234, 23, 'a'),
          ('111', 'bbb', 25, 3, 'a'),
          ('112', 'ccc', 76, 100, 'b'),
          ('113', 'ddd', 111, 99, 'b'),
          ('114', 'eee', 981, 98, 'a'),
          ('115', 'fff', 2, 96, 'a');
    
      select top 3 * from (
         select top 4 * from t_books order by price desc
      ) t_books order by price;

      select * from (
         select row_number() over (order by price desc) n, * from t_books
      ) x where n between 2 and 4;

      select * from t_books order by price desc offset 1 rows fetch next 3 rows only;
  end

  go

  --调用，执行存储过程
  exec p_selects_books;
  go
#+end_src

** Q & A (case when)
*** <TaskBox>

学生信息管理系统中有张表 STUDENT，其中，有字段 ID、NAME、SEX、BIRTH。
请回答如下问题： 
1. 找出 NAME 相同的学生（用一句SQL语句）
2. 用一句 SQL 语句把学生 SEX 为男的改为女，女的改为男

*** <RowGrid>
:PROPERTIES:
:props: theme={t2}
:END:

Case When 在 SQL 中的使用。

#+begin_example
   student
   name      sex addr weixin
   zhangsan  1,2 ..

   "select name, sex from student;"
   
   string displaySex;
   if (sex == 1) displaySex = "男"; else displaySex = "女";

   label1.Text = displaySex;

   -----
   x = 3; 赋值。 x == 3; 判断
   x := 3; x = 3
   select x = 3 ...., 歧义. where x = 3 and y = 4;
   -----

   select name, case when sex = 1 then '男' 
                case when sex = 2 then '女'
                else '未知' end from student;
   update student set sex = case when sex = 1 then 2 else 1 end;
#+end_example

SQL 行列转换

#+SPLIT: t

参考答案:

#+ATTR_HTML: :type ScCodePane
#+begin_src sql
  -- 准备工作
  create table student (id int primary key, name varchar(20), sex varchar(20), birth datetime/datetime2);
  insert into student values
      (1, '张三','男','2001-02-12')
    , (2, '李四','男','2004-06-11')
    , (3, '张三','女','2001-06-14')
    , (4, '李四','女','2003-11-21')
    , (5, '张三风','男','2001-06-12');

  -- 第一题
  select * from student where name in 
    (select name from student group by name having count(*) > 1);

  -- 第二题
  update student set sex= case when sex='男' then'女' when sex='女' then '男' end;


  ---------------------------------------

  -- 很多人不愿意用 exists，而是喜欢用 in，因为 in 更容易理解并且语句更简短
  -- 实际上，更推荐使用 exists，因为在很多场合 exists 更有效率
     -- 高额的空间占用
     -- 巨大的对比次数
  -- ANY/SOME/ALL 是 exists 的语法糖，在某些场景之下，更加直观

  select * from student where cardid in
     (select id from renkoubiao where shengfen='广东');
  select * from student s where
     exists (select * from renkoubiao r where r.id = s.cardid and r.shenfen = '广东');
#+end_src

** 游标 (Cursor)  <RowGrid>

游标, Cursor。

 var books = db.Books.Where(x => x.Name.Length > 3).ToList(); // lazy

 select * from students where like 'xxx%';

 
#+begin_src csharp
  using (SqlDataReader reader = command.ExecuteReader())
  {
      if (reader.HasRows)
      {
          while (reader.Read())
          {
              if (reader[0] > 3) {
                 Console.WriteLine("{0}: {1:C}", reader[0], reader[1]);
              }   
          }
      }
  }

  var dt = new DataTable();
  var adapter = new SqlDataAdapter("select * from orders", conn);
  adapter.Fill(dt);
#+end_src

#+SPLIT: t
  
当执行一条语句时，Oracle 会打开一片工作区，将结果保存在里面。
在这片工作区，存在一个指针，默认指向第一条记录。我们可以通过移动指针获取不同记录。

这个指针，就是游标。

游标分为隐式游标和显式游标。
- 隐式游标是 Oracle 自动管理的，比如我们进行一次 update，Oracle 会打开一个游标定位到数据，我们更新结束后，Oracle 就会把游标给关闭。
- 显式游标，就是我们要自定义的游标，主要用来处理有多条数据返回的查询。

#+SPLIT: 1
  
#+begin_src sql
  declare
    vemp emp%rowtype;
    -- 定义游标
    cursor c_emp is select * from emp where sal > 2000;
  begin
    -- 打开游标
    open c_emp;

    -- 提取游标当前数据
    fetch c_emp into vemp;
    loop
      dbms_output.put_line(vemp.ename || '的工资是' || vemp.sal);
      fetch c_emp into vemp;
      exit when c_emp%notfound;
    end loop;

    -- 关闭游标
    close c_emp;
  end;
#+end_src
  
** Join Query     <RowGrid n={3}>

朴素的数据表达，一张表:
#+begin_example
aaa (直观。浪费，维护麻烦)
zhang nan jishu  shanghai xx
li    nv  jishu  shanghai xx
wang  nan xiaoshou zhuangzhou yy
xx    nv  jishu  shanghai xx
yy    nv  jishu  zhuhai xx
#+end_example

三大范式，分解 (如果没印象，自行总结):
#+begin_example
emp               dept
zhang nan 1        1   jishu     zhuhai
li    nv  1        2   xiaoshou  guangzhou
wang  nan 2        8   weizhi    huoxing
zhao  nv  9
#+end_example

#+SPLIT: t

笛卡尔积 (叉乘):
#+begin_example
zhang nan 1  1 jishu zhuhai
zhang nan 1  2 xiaoshou guangzhou
zhang nan 1  8   weizhi    huoxing
li    nv  1  1 jishu zhuhai
li    nv  1  2 xiaoshou guangzhou
li    nv  1  8   weizhi    huoxing
wang  nan 2  1 jishu zhuhai
wang  nan 2  2 xiaoshou guangzhou
wang  nan 2  8   weizhi    huoxing
zhao  nv  9  1 jishu zhuhai
zhao  nv  9  2 xiaoshou guangzhou
zhao  nv  9  8   weizhi    huoxing
#+end_example

#+SPLIT: t

内连接:
#+begin_src sql
select * from emp e
  join dept d on e.deptno = d.deptno;
#+end_src

#+begin_example
zhang nan 1  1 jishu zhuhai
li    nv  1  1 jishu zhuhai
wang  nan 2  2 xiaoshou guangzhou
#+end_example

左连接 (请列出所有人及他们的部门信息):
#+begin_src sql
select * from emp e
  left join dept d on e.deptno = d.deptno;
#+end_src

#+begin_example
zhang nan 1  1 jishu zhuhai
li    nv  1  1 jishu zhuhai
wang  nan 2  2 xiaoshou guangzhou
zhao  nv  9  null null null
#+end_example

右连接 (请列出所有部门的人):
#+begin_src sql
select * from emp e
  right join dept d on e.deptno = d.deptno;
#+end_src

#+begin_example
zhang nan 1      1 jishu zhuhai
li    nv  1      1 jishu zhuhai
wang  nan 2      2 xiaoshou guangzhou
null  null null  8 weizhi huoxing 
#+end_example

** SQL 练习题      <Box>
*** 示例数据库和题目 <RowGrid className="pre2">

题目 (必做):
1. 查询每个部门下有多少员工
2. 查询除去 salesman 所有平均工资超过 1500 的部门
3. 查询在 new york 工作的所有员工的姓名，部门名称和工资信息
4. 查询姓名为 King 的员工的编号，名称跟部门
5. 查询各种工作的最低工资
6. 查询工龄大于 10 年的所有员工信息
7. 查询每个部门员工数量，平均工资和平均工作年限
8. 统计各部门每个工种的人数，平均工资
9. 查询从事同一种工作但不属于同一部门的员工信息
10. 查询所有员工工资都大于 1000 的部门的信息及员工信息

#+SPLIT: t

#+begin_src sql
  CREATE DATABASE oa;
  use oa;

  CREATE TABLE dept ( -- department
    deptno int,
    dname  VARCHAR(14),
    loc    VARCHAR(13), -- location/address
    CONSTRAINT pk_dept PRIMARY KEY (deptno)
  );

  CREATE TABLE emp ( -- employee
    empno    int,
    ename    VARCHAR(10),
    job      VARCHAR(9),
    mgr      int,
    hiredate DATE,
    sal      money,
    comm     money,
    deptno   int,
    CONSTRAINT pk_emp PRIMARY KEY (empno),
    CONSTRAINT fk_deptno FOREIGN KEY (deptno) REFERENCES dept (deptno)
  );

  CREATE TABLE bonus ( -- bonus
    ename VARCHAR(10),
    job   VARCHAR(9),
    sal   float,
    comm  float
  );

  CREATE TABLE salgrade ( -- salary grade
    grade int,
    losal float,
    hisal float
  );

  INSERT INTO dept VALUES(10, 'ACCOUNTING', 'NEW YORK');
  INSERT INTO dept VALUES(20, 'RESEARCH', 'DALLAS');
  INSERT INTO dept VALUES(30, 'SALES', 'CHICAGO');
  INSERT INTO dept VALUES(40, 'OPERATIONS', 'BOSTON');

  INSERT INTO emp VALUES( 7839, 'KING', 'PRESIDENT', null, '1981-11-17', 5000, null, 10 );
  INSERT INTO emp VALUES( 7698, 'BLAKE', 'MANAGER', 7839, '1981-05-01', 2850, null, 30);
  INSERT INTO emp VALUES( 7782, 'CLARK', 'MANAGER', 7839, '1981-06-09', 2450, null, 10);
  INSERT INTO emp VALUES( 7566, 'JONES', 'MANAGER', 7839, '1981-04-02', 2975, null, 20);
  INSERT INTO emp VALUES( 7788, 'SCOTT', 'ANALYST', 7566, '1987-07-13', 3000, null, 20);
  INSERT INTO emp VALUES( 7902, 'FORD', 'ANALYST', 7566, '1981-12-03', 3000, null, 20 );
  INSERT INTO emp VALUES( 7369, 'SMITH', 'CLERK', 7902, '1980-12-17', 800, null, 20 );
  INSERT INTO emp VALUES( 7499, 'ALLEN', 'SALESMAN', 7698, '1981-02-20', 1600, 300, 30);
  INSERT INTO emp VALUES( 7521, 'WARD', 'SALESMAN', 7698, '1981-02-22', 1250, 500, 30 );
  INSERT INTO emp VALUES( 7654, 'MARTIN', 'SALESMAN', 7698, '1981-09-28', 1250, 1400, 30 );
  INSERT INTO emp VALUES( 7844, 'TURNER', 'SALESMAN', 7698, '1981-09-08', 1500, 0, 30);
  INSERT INTO emp VALUES( 7876, 'ADAMS', 'CLERK', 7788, '1987-07-13', 1100, null, 20 );
  INSERT INTO emp VALUES( 7900, 'JAMES', 'CLERK', 7698, '1981-12-03', 950, null, 30 );
  INSERT INTO emp VALUES( 7934, 'MILLER', 'CLERK', 7782, '1982-01-23', 1300, null, 10 );

  INSERT INTO salgrade VALUES (1, 700, 1200);
  INSERT INTO salgrade VALUES (2, 1201, 1400);
  INSERT INTO salgrade VALUES (3, 1401, 2000);
  INSERT INTO salgrade VALUES (4, 2001, 3000);
  INSERT INTO salgrade VALUES (5, 3001, 9999);

  go
#+end_src

*** 其他题目

其他题目 (选作):

**** <RowGrid>

- 查询入职日期早于其直接上级的所有员工信息。
- 列出雇员中（除去mgr为空的人)工资第二高的人。
- 列出1981年来公司所有员工的总收入（包括sal和comm）
- 查询部门编号为 10 和 30 的所有人（用不同方式查询）
- 查询部门编号为 10 和 30 中名字中不含有 ‘C’ 的所有人
- 查询部门编号为 10 和 30 中名字首字母之外不含有 ‘C’ 的所有人

#+SPLIT: t
  
- 查询部门编号为 10 和 30 中所有的经理以及名字首字母之外不含有 ‘C’ 的所有人
- 查询纽约和芝加哥地区所有的经理以及名字首字母之外不含有 ‘C’ 的所有人
- 查询纽约和芝加哥地区所有的经理以及顶头上司名字的首字母之外不含有 ‘C’ 的所有人
- 查询每个人的工资等级
- 查询每个部门的平均工资的等级
- 查询每个组最高工资的那些人

** 练习题答疑      <RowGrid className="ans1">

查询每个部门下有多少员工:

#+begin_src sql
  select * from emp;
  select count(*) from emp;
  select count(*) from emp group by deptno;
  select deptno, count(*) from emp group by deptno;

  select dept.*, x.cnt from (select deptno, count(*) cnt from emp group by deptno) x
     join dept on dept.deptno = x.deptno; 

  select d.dname, count(*) from emp e
    join dept d on e.deptno = d.deptno
    group by d.dname;
#+end_src

查询除去 salesman 所有平均工资超过 2000 的部门:
 
#+begin_src sql
  -- 查询所有部门的平均工资
  select sal from emp;
  select avg(sal) from emp;
  select deptno, avg(sal) from emp group by deptno;

  -- 除去 saleman 之外的，所有部门的平均工资
  select deptno, avg(sal) from emp where job <> 'SALESMAN' group by deptno;

  -- 除去 saleman 之外的，所有部门的平均工资，超过 2000 的
  select * from (select deptno, avg(sal) as v from emp where job <> 'SALESMAN' group by deptno) x
     where v > 2000;
  select deptno, avg(sal) from emp where job <> 'SALESMAN' group by deptno having avg(sal) > 2000;

  -- 关联 dept 信息
  select * from dept where deptno in (
      select deptno from emp where job <> 'SALESMAN' group by deptno having avg(sal) > 2000
  );

  select dept.dname, avg(sal) from emp
      join dept on emp.deptno = dept.deptno
      where job <> 'SALESMAN'
      group by dept.dname
      having avg(sal) > 2000;

  select d.* from (select deptno from emp where job <> 'SALESMAN' group by deptno having avg(sal) > 2000) t 
    join dept d on t.deptno = d.deptno;
#+end_src

查询在 new york 工作的所有员工的姓名，部门名称和工资信息

#+begin_src sql
  select ename, d.dname, sal, d.loc from emp e
     join dept d on e.deptno = d.deptno
     where d.loc = 'NEW YORK'
#+end_src

查询姓名为 King 的员工的编号，名称跟部门

#+begin_src sql
  select e.empno, e.ename, d.deptno, d.dname, d.loc from emp e 
    join dept d on e.deptno = d.deptno
    where e.ename = 'KING';
#+end_src

查询各种工作的最低工资

#+begin_src sql
  select job, min(sal) minsal from emp group by job;
#+end_src

#+SPLIT: t

查询工龄大于 10 年的所有员工信息

#+begin_src sql
  select * from emp where
    datediff(year, hiredate, getdate()) > 10;
#+end_src

查询每个部门员工数量，平均工资和平均工作年限

#+begin_src sql
  select
      d.dname, 
      count(*),
      avg(e.sal),
      avg(datediff(year, e.hiredate, getdate()))
    from emp e join dept d on e.deptno = d.deptno
    group by d.dname;
#+end_src

统计各部门每个工种的人数，平均工资

#+begin_src sql
  select deptno, job, count(*), avg(sal) from emp
    group by deptno, job;
#+end_src

查询从事同一种工作但不属于同一部门的员工信息

#+begin_src sql
  -- 此类问题的解决方案基本都是这样的
  select * from emp a join emp b
    on a.job = b.job
    where a.empno > b.empno
      and a.deptno <> b.deptno;
#+end_src

查询所有员工工资都大于 1000 的部门的信息及员工信息

#+begin_src sql
  select * from dept d join emp e on e.deptno = d.deptno 
    where e.deptno in (select deptno from emp
                         group by deptno having min(sal) > 1000);

  select * from dept d join emp e on e.deptno = d.deptno 
    where exists (select deptno from emp 
                    group by deptno having min(sal) > 1000 and deptno = d.deptno);
#+end_src

* Entity Framework
:PROPERTIES:
:layout: top
:END:
** Entity Framework 简介 <RowGrid>

ORM (Object - Relationship, Mapping)
- Hibernate/Jpa
- EF

EF1:
- 适用于 .NET3.5
- EF1 是基于 Provider 的; 另一个产品 LINQ to SQL 提供了跟 EF1 类似的功能，它更简单但只能用于 SqlServer
- 模型必须要派生自 EntityObject, 使用一个包含 XML 的 EDMX 文件进行对象和关系映射

EF4:
- 适用于 .NET4，进行了重大改进。因为改动大，所以版本跳过了 2/3 直接到 4
- 增加了懒加载，设计模型后可以使用 SQL 创建数据库，不需要派生 EntityObject
- 支持两个模型: Database First 和 Model First
- 后来的更新使用 NuGet 包添加了额外功能。4.1 增加了 Code First 模型，不再使用 EDMX 定义映射。4.3 增加了 Migrate 功能

EF5:
- EF5 的 NuGet 包，支持 .NET4.0 和 .NET4.5。它仍基于安装在系统上的类型和 .NET Framework 4.5
- 新增了功能改进，如支持新的 SqlServer 功能，比如空间数据库

#+SPLIT: t

EF6:
- 解决了 EF5 中的一些问题，并完全移植到了 NuGet 包中
- 为了避免冲突，使用了新的命名空间

EF Core:
- 是对 EF 的完全重写
- 可以支持 Linux 和 Mac，
- 支持关系数据库和 NoSQL (No only sql, no sql. Redis, Mongodb)
- EF Core2 不支持 XML 映射于 CSDL/SSDL/MSL，只支持 Code First
- https://docs.microsoft.com/zh-cn/ef/

特点:
- 开发效率高；跨平台，跨数据库的能力强大
- 相对来说，性能问题

** EF Core 基本使用       <RowGrid>

创建项目:
#+begin_src sh
  dotnet new console MyConsoleWithEFC
#+end_src

添加相关依赖:
#+begin_src shell
  dotnet add package Microsoft.EntityFrameworkCore

  dotnet add package Microsoft.EntityFrameworkCore.SqlServer
  dotnet add package Microsoft.EntityFrameworkCore.SQLite
  dotnet add package MySQL.Data.EntityFrameworkCore
  dotnet add package Microsoft.EntityFrameworkCore.InMemory
#+end_src

创建模型和 DbContext:
#+begin_src csharp
  public class Book
  {
      public int BookId { get;set; }
      public string Name { get; set; }
      public string Author { get; set; }
  }
  public class MyDbContext : DbContext 
  {
      public DbSet<Book>? Books {get; set;}

      protected override void OnConfiguring(DbContextOptionsBuilder builder) {
          base.OnConfiguring(builder);
          builder.UseSqlServer("server=.;database=mytest2;uid=sa;pwd=sa1234;Trust Server Certificate=true");
      }
  }
#+end_src

#+SPLIT: t

开始使用:
#+begin_src csharp
  using var db = new MyDbContext();
  db.Database.EnsureDeleted();
  db.Database.EnsureCreated();

  db.Books.Add(new Book { Name = "呐喊", Author = "鲁迅"});
  db.Books.Add(new Book { Name = "彷徨", Author = "鲁迅"});
  db.Books.Add(new Book { Name = "野草", Author = "鲁迅"});
  db.Books.Add(new Book { Name = "阿Q正传", Author = "鲁迅"});
  db.Books.Add(new Book { Name = "茶馆", Author = "老舍"});

  db.SaveChanges();

  Book book = db.Books.Where(b => b.Name != "鲁迅").First();
  System.Console.WriteLine($"shuming: {book.Name}, zuozhe: {book.Author}");

  db.Books.Where(p => p.Name == "野草").First().Name = "野草集";
  db.SaveChanges();

  DB.Books.First(p => p.Name == "彷徨").Remove();
  db.SaveChanges();

  System.Console.WriteLine("结束了");
#+end_src

** EF 中进行建模          <ColFlexBox>

有两种方式在 EF 中进行建模:
1. 基于 edmx 1) 从模型生成数据库，Model-First 2) 从数据库生成模型，Database-First
   - EDMX (Entity Data Model Xml) 方式可以可视化建模
   - 它使用后缀为 .edmx 的 XML 格式的文件对模型进行描述
   - .edmx 文件很复杂，主要包括 csdl/ssdl/msl 三部分
   - EF Core 中，不支持 edmx 建模方式
2. 基于 C# 代码 3) 称作 Code-First


示例代码:
#+begin_src csharp
  [Table("my_books")]
  public class Book
  {
      public int BookId {get;set;}
      public string Name {get; set;}
      public string Author {get; set;}
  }

  public class MyDbContext : DbContext 
  {
      protected override void OnModelCreating(ModelBuilder modelBuilder)
      {
          modelBuilder.Entity<Book>().ToTable("table_book_hahaha");
      }
  }
#+end_src

#+SPLIT: t

模型定义，分为三个层面:
1. CoC 原则 (约定大于配置)
   - DbContext 类中 DbSet 属性的名称，映射为表的名称
   - 类中的属性名称，映射为表的字段名称
   - string 映射为 nvarchar; int 映射为 int
   - Id 后缀命名的 int/Guid 类型，自动映射到主键
   - 字段或只有 get 或私有的属性并不能被映射到数据库。但是可以使用 HasField 方法进行强制映射
   - 可以使用 Fluent API 中使用字符串的方式设置阴影属性，这样的属性只存在于数据库而不用于模型
2. 基于注解 (System.ComponentModel.DataAnnotations.Schema):
   - ~[Table/Column/ComplexType/NotMapped]~
   - ~[Required/MaxLength/StringLength]~
   - ~[Key], HasKey, HasName, HasPrincipalKey, HasAlternateKey~, 指定主键、备用键
   - ~[Index], HasIndex~, 指定索引
   - ~[ForeignKey], HasForeignKey, HasConstraintName~, 放在导航属性上，用于显式指定 ref 的字段。当主键的名字不是约定的 XxId 格式需要
   - ~[InverseProperty] HasOne, WithMany~, 放在导航属性多的一端，用于显式指定 ref 的字段。当两个模型定义了多个导航属性，且导航关系不明确时使用，解决歧义
   - ~[ConcurrencyCheck], IsConcurrencyToken~, 并发性检查，如果更新的时候发现当前字段已经被别人修改过，那么会抛出错误
   - ~[TimeStamp], IsRowVersion~, 类似于 ConcurrencyCheck，只不过使用时间戳的方式，利用一个单独的字段表达数据是否被修改
   - ~[DatabaseGenerated] ValueGeneratedOnAdd, ValueGeneratedNever, HasDefaultValue, HasDefaultSql, HasComputedColumnSql~, 用来指定初始值的产生方式
3. Fluent API
   - 我们可以在 DbContext 的 OnModelCreating 中添加逻辑，从而替代 [注解] 的方式进行数据库的配置
   - 使用 Entity/Property 返回要操作的实体或属性，使用 ToTable 为数据库设定名字, 使用 HasData 播种
     
** 三种层次建模的示例      <FlexBox>

#+begin_src csharp
  class MenuCard
  {
      public int MenuCardId { get; set; }
      public string Title { get; set; }
      public List<Menu> Menus { get; } = new List<Menu>();
      public override string ToString() => Title;
  }

  [Table("Menus", Schema = "mc")]
  class Menu
  {
      public int MenuId { get; set; }
      [MaxLength(50)]
      public string Text { get; set; }
      [Column(TypeName = "Money")]
      public decimal Price { get; set; }
      public MenuCard MenuCard { get; set; }
      public override string ToString() => Text;
  }

  class BooksContext : DbContext
  {
      protected override void OnModelCreating(ModelBuilder builder)
      {
          base.OnModelCreating(builder);
          builder.HasDefaultSchema("mc");
          builder.Entity<MenuCard>().ToTable("MenuCards").HasKey(c => c.MenuCardId);
          builder.Entity<MenuCard>().Property(c => c.MenuCardId).ValueGeneratedOnAdd();
          builder.Entity<MenuCard>().Property(c => c.Title).HasMaxLength(50);
          //builder.ApplyConfiguration(new YourConfigurationFromIEntityTypeConfigurationSinceEFCore2ToSeperateCode());
      }
  }
#+end_src

** 构建模型关系的示例      <RowGrid>

#+begin_src csharp
  public class Book
  {
      public int BookdId { get; set; }
      public int Title { get; set; }
      public List<Chapter> Chapters { get; } = new List<Chapter>();
  
      public int? AuthorId { get; set; }
      [ForeignKey(nameof(AuthorId))]
      public User Author { get; set; }
      public int? ReviewerId { get; set; }
      [ForeignKey(nameof(ReviewerId))]
      public User Reviewer { get; set; }
      public int? ProjectEditorId { get; set; }
      [ForeignKey(nameof(ProjectEditorId))]
      public User ProjectEditor { get; set; }
  }
  
  public class User
  {
      public int UserId { get; set; }
      public string Name { get; set; }
      [InverseProperty("Author")]
      public List<Book> WrittenBooks { get; set; }
      [InverseProperty("Reviewer")]
      public List<Book> ReviewedBooks { get; set; }
      [InverseProperty("ProjectEditor")]
      public List<Book> EditedBooks { get; set; }
  }
#+end_src

#+SPLIT: t

#+ATTR_HTML: :className codeheight80
#+begin_src csharp
  public class Book
  {
      public int BookdId { get; set; }
      public int Title { get; set; }
      public List<Chapter> Chapters { get; } = new List<Chapter>();

      public User Author { get; set; }
      public User Reviewer { get; set; }
      public User ProjectEditor { get; set; }
  }

  public class User
  {
      public int UserId { get; set; }
      public string Name { get; set; }
      public List<Book> WrittenBooks { get; set; }
      public List<Book> ReviewedBooks { get; set; }
      public List<Book> EditedBooks { get; set; }
  }

  public class Chapter
  {
      public int ChapterId { get; set; }
      public int Number { get; set; }
      public string Title { get; set; }
      public int BookId { get; set; }
      public Book Book { get; set; }
  }

  builder.Entity<Book>().HasMany(b => b.Chapters).WithOne(c => c.Book);
  builder.Entity<Book>().HasOne(b => b.Author).WithMany(a => a.WrittenBooks);
  builder.Entity<Book>().HasOne(b => b.Reviewer).WithMany(r => r.ReviewedBooks);
  builder.Entity<Book>().HasOne(b => b.ProjectEditor).WithMany(r => r.EditedBooks);
  builder.Entity<Chapter>().HasOne(c =>c.Book).WithMany(b => b.Chapters).HasForeignKey(c => c.BookId);
  builder.Entity<User>().HasMany(a => a.WrittenBooks).WIthOne(b => b.Author);
  builder.Entity<User>().HasMany(a => a.ReviewedBooks).WIthOne(b => b.Reviewer);
  builder.Entity<User>().HasMany(a => a.EditedBooks).WIthOne(b => b.ProjectEditor);
#+end_src

** EF 练习题
*** <TaskBox>

使用 EF 为一个博客系统建模:
- 至少包括三个实体: Blog 表示某个人的博客; Post 表示其中一篇博客; Comment 表示某篇博客的评论
- 按照实际场景，确定实体之间的关系。请自行分析
- 使用 EF 的 Code First 方式进行建模。无其他要求，须结果正确即可

* <config>                                                           :NOEXPORT:
** global styles

#+THEME: t1
#+EXPORT_LEVEL: 1

#+begin_src js
  const t1 = {
      ...defaultTheme,
      fontSizes: {
          text: "14px",
          monospace: "14px"
      },
      fonts: {
          text: "\"Helvetica Neue\", Helvetica, Arial, sans-serif"
      },
      space: [10, 8, 20],
      size: { width: "100%", height: "100%", maxCodePaneHeight: 100 }
  }
  const t2 = {
      ...t1,
      fontSizes: {
          text: "34px",
          monospace: "34px"
      },
  }
  console.log(defaultTheme);
#+end_src

#+begin_src css
  pre { margin: 5px 1em !important; }
  .example pre { background-color:transparent !important; margin: 0 2em !important; }
  .ans1 pre { max-height: 55px !important; }
  .pre2 pre { max-height: 300px !important; margin: 3em 2em 0 0 !important; }
  .codeheight60 pre { max-height: 60vh !important; }
  .codeheight70 pre { max-height: 70vh !important; }
  .codeheight80 pre { max-height: 80vh !important; }

  li>ul { padding: 0 }

  ::-webkit-scrollbar {
    width: 5px;
    height: 80%;
  }

  ::-webkit-scrollbar-track {
    background: rgb(179, 177, 177);
    border-radius: 5px;
  }

  ::-webkit-scrollbar-thumb {
    background: rgb(136, 136, 136);
    border-radius: 5px;
  }

  ::-webkit-scrollbar-thumb:hover {
    background: rgb(100, 100, 100);
    border-radius: 5px;
  }

  ::-webkit-scrollbar-thumb:active {
    background: rgb(68, 68, 68);
    border-radius: 5px;
  }
#+end_src

** Components

#+EXTERN_COMPONENTS: ColFlexBox RowFlexBox RowGrid TaskBox

#+begin_src js
  const ColFlexBox = (props) => {
      return html`<${FlexBox} 
           style=${{flexFlow: "column wrap", justifyContent: "flex-start", alignItems: "stretch", height: "90%"}}
           ...${props}>
        </${FlexBox}>`
  };
  const RowFlexBox = (props) => {
      return html`<${FlexBox}
           style=${{flexFlow: "row nowrap", justifyContent: "flex-start", alignItems: "stretch", alignContent: "stretch" }}
           ...${props}>
        </${FlexBox}>`
  };
  const RowGrid = (props) => {
      const n = props.n || 2;
      return html`<${Grid} gridTemplateColumns=${"minmax(100px, 1fr) ".repeat(n).trim()} ...${props}></${Grid}>`
  };
  const TaskBox = (props) => {
      return html`<${Box}  backgroundColor="rgba(0,0,0,0.2)" padding="10px" ...${props}></${Box}>`
  };
  const ScCodePane = (props) => {
      return html`<${Box} className="code-scroll"><${CodePane} ...${props}></${CodePane}></${Box}>`;
  }
#+end_src

#+begin_src css
  .code-scroll pre {
      height: 450px;
      overflow: auto;
  }
#+end_src

** Slide Component

#+EXTERN_COMPONENTS: MySlide

#+slide_opts: MySlide

#+begin_src js
  const MySlide = (props) => {
      const colors = ["red", "orange", "yellow", "green", "blue", "cyan", "purple"];
      let bg = "linear-gradient(135deg, ";
      for (let i = 0; i < 19; i++) {
          const c = colors[i%7];
          bg = bg + c + " " + (i*5) + "%, " + c + " " + ((i+1)*5) + "%, ";
      }
      bg += "white 100%)";
      let bg2 = "linear-gradient(150deg, darkred, 20%, rgba(100,100,0,0.5), 30%, rgba(0,0,0,0), 70%, transparent)";
      return html`<${Slide} ...${props}>
  <${Text} fontFamily="kaiti" fontSize=${20} margin="-20px -20px 1em -20px" padding="5px 1em" style=${{ backgroundImage: bg2}}>
    ${props.title}
  </{Text}>
  <div>
    ${props.children}
  </div>
  </${Slide}>`;
  }
#+end_src
