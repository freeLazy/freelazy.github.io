#+TITLE: Database

* Overview
:PROPERTIES:
:layout: Center
:END:

#+ATTR_HTML: :type Heading :fontFamily kaiti
使用 .NET 操作数据库

#+ATTR_HTML: :theme {{ fontSizes: { text: "50px" }}} :style {{ margin: "1em 2em" }}
- ADO.NET
- Entity Framework
- Entity Framework Core
- Dapper/FreeSQL

* ADO.NET
:PROPERTIES:
:layout: top
:END:
** ADO.NET         <RowGrid>
*** <Box>

ADO.NET:
- System.Data.dll
- DbConnection, DbCommand, DataReader, DataAdapter, DataSet
- SqlConnection (SqlServer)

#+SPLIT: 2

Entity Framework:

#+begin_example
  
 你 SQL 语句  ---->   SQL 服务器
            <-----


 EF  --object---> 翻译 --sql---->  SQL 服务器
     <--object--- 封装 ---data---

#+end_example

优点缺点:
1. 多了中间环节。CPU 内存
2. 翻译质量怎么样?

ChatGPT

*** <Box>

首先，添加依赖:
#+begin_src shell
  dotnet add package System.Data.SqlClient # SqlServer
  dotnet add package MySql.Data            # MySQL
  dotnet add package Microsoft.Data.Sqlite # SQLite
#+end_src

其次，直接使用相关对象完成数据库操作:
#+begin_src csharp

  // Connection 对象，通道
  using var conn = new SqlConnection("lianjiezifuchuan");
  conn.Open();

  // Command 对象，用来描述我们的任务
  var cmd = new SqlCommand("select * from xxx where id=@id", conn);
  cmd.Parameters.AddWithValue("id", 3);

  // 执行、发布任务
  int num = cmd.ExecuteNonQuery();      // 增删改
  var reader = cmd.ExecuteReader();     // 基于游标的对象
  var object = cmd.ExecuteScalar();     // 第一行的第一列
  new DataAdapter(cmd).Fill(dataTable); // 一次到位封装到既定对象中
#+end_src

整理总结，Sql 连接字符串的写法:
#+begin_src csharp
  "server=localhost;database=BookDB;uid=sa;pwd=sa1234";        // 用户名密码登陆
  "server=127.0.0.1;database=BookDB;integrated security=SSPI"; // Windows 用户登陆
  "server=.;database=BookDB;integrated security=SSPI";         // 使用 . 代表 localhost
  "Data Source=localhost;initial catalog=BookDB;integrated security=True;Connect Timeout=30";
#+end_src

** Procedure       <RowGrid>
*** <Box>

存储过程:
- 什么是存储过程?
- 使用存储过程有什么优点和缺点?

#+begin_quote
存储过程是一组预编译的 SQL 语句，它可以包含数据操作语句和变量逻辑等。\\
它保存在数据库中，通过名字可以反复使用。

#+SPLIT: 2

优点:
- 效率高
- 提高系统的安全性
- 技术成本

缺点:
- 禁止使用存储过程，存储过程难以调试和扩展，更没有移植性
#+end_quote


SQL (Sequence Query Language)
:   -- 发送一句话
:   -- 回应一句话

不是标准。PLSQL/TSQL

[shengchengdingdan] -> 查询 -- 生成 -- 插入订单 -.......

C# -> shengchengdingdan

*** <Box>

编写存储过程:
#+begin_src sql
  -- 创建
  create procedure p_aa1 as
    create table xxx (a int, b varchar(20));
    insert into xxx values (1, 2), (2, 3), (3, 4);
    select * from xxx;
    waitfor delay '00:00:20' drop table xxx;
  GO

  -- 执行
  exec p_aa1;
  GO

  -- 删除
  drop procedure p_aa1;
  drop proc p_aa1;

  -- 修改
  alter procedure p_aa1 as
    select * from emp;
#+end_src

** 存储过程代码示例  <ColFlexBox>

没有参数:
#+begin_src sql
  create procedure p_aaa as select * from xxx;
  exec p_aaa;
#+end_src

#+SPLIT: t

带有参数:
#+begin_src sql
  create procedure
    p_aaa @name varchar(20) 
  as
    select * from xxx where name < @name;

  exec p_aaa 30;
#+end_src

#+SPLIT: t

带有参数，还有默认值:
#+begin_src sql
  create procedure p_aaa
    @name varchar(20) = 'Tom'
  as
    select * from xxx where name < @name;

  exec p_aaa;
  exec p_aaa 'xxx';
#+end_src

#+SPLIT: t

带 output 参数的存储过程:
#+begin_src sql
  create procedure p_aaa
    @r int output
  as
    select @r = count(*) from xxx;

  -- 调用
  declare @rrr int;
  exec p_aaa @rrr output;
#+end_src

#+SPLIT: t

混合各种参数:
#+begin_src sql
  create procedure p_aaa
    @n varchar(20) = 'TOM',
    @r int output
  as
    select @r = count(*) from xxx where name < @n;

  -- 调用
  declare @rrr int;
  exec p_aaa 'Cat', @rrr output;

  -- 查看返回的结果
  select @rrr;
#+end_src

** 系统存储过程

系统内置的存储过程，一般是 sp_ 开始 (system procedure):
#+begin_src sql
  exec sp_databases;
  exec sp_help;
  exec sp_helptext sp_databases;
  exec sp_helptext sp_helptext; -- 查看存储过程怎么写的

  exec sp_tables;
  exec sp_columns emp;
#+end_src

扩展出来的存储过程以 xp_ 开始 (extenstion procedure):
#+begin_src sql
  exec xp_cmdshell 'mkdir e:\hello';
  exec xp_fileexist 'e:\hello';

  -- xp_enumgroups;
  -- xp_loginconfig
  -- xp_msver
  -- xp_grantlogin;
  -- ...
#+end_src

** 使用存储过程实现报表

为 emp 生成统计数据，统计所有部门的平均工资、最小工资和最大工资，将结果保存到 tj_emp 表中。要求:
- 如果这张表不存在，那么创建
- 如果这张表存在，但是里面有数据，清空它
- 如果插入完成，在日志表 (my_log) 插入一条信息

*** <Appear>

写法示例，仅供参考:

#+ATTR_HTML: :style {{ margin: "1em" }}
#+begin_src sql
  create procedure p_tj_emp
    @lowsal int = 1000,
    @highsal int = 10000
  as
  begin
    -- 如果不存在，创建之
    if not exists (select * from sys.tables where name = 'tj_emp')
       create table tj_emp (deptno int, a float, b float, c float);
    -- 清空数据
    truncate table tj_emp;
    -- 插入新的数据
    insert into tj_emp select deptno, avg(sal) as a, max(sal) as b, min(sal) as c from emp
      where sal >= @lowsal and sal <= @highsal
      group by deptno;
    -- 记录日志
    insert into my_log (message) values ('统计完成 - ' + convert(varchar(200), getdate(), 20));
    -- 结束
    print 'hello, finished.';
  end
#+end_src

** 数据库中的其他对象 <RowGrid>
*** <Box>

数据库中的其他对象:
- Table/Index
- View 视图，虚表
- Function 函数
- Trigger 触发器

#+ATTR_HTML: :margin 2em 0
#+begin_src sql
  -- 视图
  create view zh_works as select * from works where city = '珠海';
  select * from zh_works where sal > 2000;
  select * from works where city = '珠海' and sal > 2000;

  -- 函数，返回值
  select getdate();
  select 32000/datediff(day,'2019-08-05','2020-08-07');
  select rand() + 3333;
#+end_src

*** <Box>

对于函数，一定要有返回值:
#+begin_src sql
  create function pingjungongzi (@deptno int) returns int
  as
  begin
    declare @avgsal int;
    select @avgsal = avg(sal) from emp where deptno = @deptno;
    return @avgsal;
  end;

  -- 调用刚才的函数
  select dbo.pingjungongzi(20);

  -- 另外调用方式
  declare @s int;
  exec @s = pingjungongzi 20;
#+end_src

触发器:
#+begin_src sql
  -- 触发器被自动执行
  create trigger tri_emp_insert_jiagongzi
    on emp
    after insert
  as -- inserted 表示插入的数据形成的临时表，名字就叫 inserted
    update emp set sal = sal + 100 where empno = (select mgr from inserted);

  -- 测试
  select * from emp;
  insert into emp (empno, ename, mgr, deptno, sal)
    values (999, 'ganmaoling', 7902, 10, 2000);
#+end_src

** 使用 ADO.NET 操作存储过程

首先，确保存储过程已存在:
#+begin_src sql
  create procedure [CSharp].[GetBooks] @name nvarchar(20)
     as select * from books where name = @name
#+end_src

使用 ADO.NET 的语法操作存储过程:
#+begin_src csharp
  var command = conn.CreateCommand();
  command.CommandText = "[CSharp].[GetBooks]";
  command.CommandType = CommandType.StoredProcedure;

  var p1 = command.CreateParameter();
  p1.SqlDbType = SqlDbType.NvarChar;
  p1.ParameterName = "@name";
  p1.Value = "xxx";
  command.Parameters.Add(p1);

  conn.Open();

  using var reader = command.ExecuteReader();
  while(reader.Read())
  {
      Console.WriteLine($"{(int)reader[1]}");
  }
#+end_src

** Q & A (row_number/pagination)
*** <TaskBox>

写一个 SQL 存储过程:
- 建立一个表 Books, 字段是编号、书名、价格、库存、入库日期 （如果表不存在）
- 向里面插入 6 条数据 (如果不存在数据)
- 然后查询出除了价格最高的书之外的价格最高的 3 条数据

*** <ColFlexBox>
:PROPERTIES:
:props: theme={t2}
:END:

分页的基本实现方式:
1. Top
2. row_number 窗口函数
3. offset fetch next

#+begin_example
row_number:
- 先分区 (partition by, 如果没有，那么将整个数据集作为一个分区)
- 再基于每个分区执行排序 (order by)
- 再给每个分区的每条数据添加行号
#+end_example

返回: 所有的书籍，每种类型价格排第二的数据:
#+begin_src sql
  select * from (
    select row_number() over (partition by category order by price desc) n,
           ,* from t_books
  ) x where n = 2;
#+end_src

#+SPLIT: t

参考答案:

#+ATTR_HTML: :type ScCodePane
#+begin_src sql
  -- 数据库一般是不区分大小写的，所以最好不要使用驼峰命名
  -- 命名的时候，最好遵循一定的规范。比如存储过程 p 开始，触发器 tr/tri;
  -- 勿以善小而不为，勿以恶小而为之。从细节做起，别妥协，不要养成不好的习惯

  if exists (select * from sys.objects where name  ='p_selects_books')
      drop procedure p_selects_books   -- 风险性提醒

  go

  create procedure p_selects_books
  as
  begin
      if not exists (select * from sys.objects where name  ='t_books')
        create table t_books (
          isbn varchar(100) primary key,
          name varchar(100) not null, 
          price money not null check(price > 0),
          amount int default 0,
          category varchar(20),
          updated_at datetime default getdate()
      );

      if not exists (select top 1 * from t_books)
        insert into t_books (isbn, name, price, amount, category) values
          ('110', 'aaa', 234, 23, 'a'),
          ('111', 'bbb', 25, 3, 'a'),
          ('112', 'ccc', 76, 100, 'b'),
          ('113', 'ddd', 111, 99, 'b'),
          ('114', 'eee', 981, 98, 'a'),
          ('115', 'fff', 2, 96, 'a');
    
      select top 3 * from (
         select top 4 * from t_books order by price desc
      ) t_books order by price;

      select * from (
         select row_number() over (order by price desc) n, * from t_books
      ) x where n between 2 and 4;

      select * from t_books order by price desc offset 1 rows fetch next 3 rows only;
  end

  go

  --调用，执行存储过程
  exec p_selects_books;
  go
#+end_src

** Q & A (case when)
*** <TaskBox>

学生信息管理系统中有张表 STUDENT，其中，有字段 ID、NAME、SEX、BIRTH。
请回答如下问题： 
1. 找出 NAME 相同的学生（用一句SQL语句）
2. 用一句 SQL 语句把学生 SEX 为男的改为女，女的改为男

*** <RowGrid>
:PROPERTIES:
:props: theme={t2}
:END:

Case When 在 SQL 中的使用。

#+begin_example
   student
   name      sex addr weixin
   zhangsan  1,2 ..

   "select name, sex from student;"
   
   string displaySex;
   if (sex == 1) displaySex = "男"; else displaySex = "女";

   label1.Text = displaySex;

   -----
   x = 3; 赋值。 x == 3; 判断
   x := 3; x = 3
   select x = 3 ...., 歧义. where x = 3 and y = 4;
   -----

   select name, case when sex = 1 then '男' 
                case when sex = 2 then '女'
                else '未知' end from student;
   update student set sex = case when sex = 1 then 2 else 1 end;
#+end_example

SQL 行列转换

#+SPLIT: t

参考答案:

#+ATTR_HTML: :type ScCodePane
#+begin_src sql
  -- 准备工作
  create table student (id int primary key, name varchar(20), sex varchar(20), birth datetime/datetime2);
  insert into student values
      (1, '张三','男','2001-02-12')
    , (2, '李四','男','2004-06-11')
    , (3, '张三','女','2001-06-14')
    , (4, '李四','女','2003-11-21')
    , (5, '张三风','男','2001-06-12');

  -- 第一题
  select * from student where name in 
    (select name from student group by name having count(*) > 1);

  -- 第二题
  update student set sex= case when sex='男' then'女' when sex='女' then '男' end;


  ---------------------------------------

  -- 很多人不愿意用 exists，而是喜欢用 in，因为 in 更容易理解并且语句更简短
  -- 实际上，更推荐使用 exists，因为在很多场合 exists 更有效率
     -- 高额的空间占用
     -- 巨大的对比次数
  -- ANY/SOME/ALL 是 exists 的语法糖，在某些场景之下，更加直观

  select * from student where cardid in
     (select id from renkoubiao where shengfen='广东');
  select * from student s where
     exists (select * from renkoubiao r where r.id = s.cardid and r.shenfen = '广东');
#+end_src

** Cursor           <RowGrid>
*** <Box>

游标, Cursor。

   var books = db.Books.Where(x => x.Name.Length > 3).ToList(); // lazy

   select * from students where like 'xxx%';

   
  #+begin_src csharp
    using (SqlDataReader reader = command.ExecuteReader())
    {
        if (reader.HasRows)
        {
            while (reader.Read())
            {
                if (reader[0] > 3) {
                   Console.WriteLine("{0}: {1:C}", reader[0], reader[1]);
                }   
            }
        }
    }

    var dt = new DataTable();
    var adapter = new SqlDataAdapter("select * from orders", conn);
    adapter.Fill(dt);
  #+end_src
  
*** <Box>
  
当执行一条语句时，Oracle 会打开一片工作区，将结果保存在里面。
在这片工作区，存在一个指针，默认指向第一条记录。我们可以通过移动指针获取不同记录。

这个指针，就是游标。

游标分为隐式游标和显式游标。
- 隐式游标是 Oracle 自动管理的，比如我们进行一次 update，Oracle 会打开一个游标定位到数据，我们更新结束后，Oracle 就会把游标给关闭。
- 显式游标，就是我们要自定义的游标，主要用来处理有多条数据返回的查询。

#+ATTR_HTML: :marginTop 1em
#+begin_src sql
  declare
    vemp emp%rowtype;
    -- 定义游标
    cursor c_emp is select * from emp where sal > 2000;
  begin
    -- 打开游标
    open c_emp;

    -- 提取游标当前数据
    fetch c_emp into vemp;
    loop
      dbms_output.put_line(vemp.ename || '的工资是' || vemp.sal);
      fetch c_emp into vemp;
      exit when c_emp%notfound;
    end loop;

    -- 关闭游标
    close c_emp;
  end;
#+end_src
  

** 练习题
*** 示例数据库和题目 <RowGrid>

#+ATTR_HTML: :type Heading :fontSize {40}
SQL 练习题

题目 (必做):
1. 查询每个部门下有多少员工
2. 查询除去 salesman 所有平均工资超过 1500 的部门
3. 查询在 new york 工作的所有员工的姓名，部门名称和工资信息
4. 查询姓名为 King 的员工的编号，名称跟部门
5. 查询各种工作的最低工资
6. 查询工龄大于 10 年的所有员工信息
7. 查询每个部门员工数量，平均工资和平均工作年限
8. 统计各部门每个工种的人数，平均工资
9. 查询从事同一种工作但不属于同一部门的员工信息
10. 查询所有员工工资都大于 1000 的部门的信息及员工信息

#+SPLIT: t

#+ATTR_HTML: :type ScCodePane
#+begin_src sql
  CREATE DATABASE oa;
  use oa;

  CREATE TABLE dept ( -- department
    deptno int,
    dname  VARCHAR(14),
    loc    VARCHAR(13), -- location/address
    CONSTRAINT pk_dept PRIMARY KEY (deptno)
  );

  CREATE TABLE emp ( -- employee
    empno    int,
    ename    VARCHAR(10),
    job      VARCHAR(9),
    mgr      int,
    hiredate DATE,
    sal      money,
    comm     money,
    deptno   int,
    CONSTRAINT pk_emp PRIMARY KEY (empno),
    CONSTRAINT fk_deptno FOREIGN KEY (deptno) REFERENCES dept (deptno)
  );

  CREATE TABLE bonus ( -- bonus
    ename VARCHAR(10),
    job   VARCHAR(9),
    sal   float,
    comm  float
  );

  CREATE TABLE salgrade ( -- salary grade
    grade int,
    losal float,
    hisal float
  );

  INSERT INTO dept VALUES(10, 'ACCOUNTING', 'NEW YORK');
  INSERT INTO dept VALUES(20, 'RESEARCH', 'DALLAS');
  INSERT INTO dept VALUES(30, 'SALES', 'CHICAGO');
  INSERT INTO dept VALUES(40, 'OPERATIONS', 'BOSTON');

  INSERT INTO emp VALUES( 7839, 'KING', 'PRESIDENT', null, '1981-11-17', 5000, null, 10 );
  INSERT INTO emp VALUES( 7698, 'BLAKE', 'MANAGER', 7839, '1981-05-01', 2850, null, 30);
  INSERT INTO emp VALUES( 7782, 'CLARK', 'MANAGER', 7839, '1981-06-09', 2450, null, 10);
  INSERT INTO emp VALUES( 7566, 'JONES', 'MANAGER', 7839, '1981-04-02', 2975, null, 20);
  INSERT INTO emp VALUES( 7788, 'SCOTT', 'ANALYST', 7566, '1987-07-13', 3000, null, 20);
  INSERT INTO emp VALUES( 7902, 'FORD', 'ANALYST', 7566, '1981-12-03', 3000, null, 20 );
  INSERT INTO emp VALUES( 7369, 'SMITH', 'CLERK', 7902, '1980-12-17', 800, null, 20 );
  INSERT INTO emp VALUES( 7499, 'ALLEN', 'SALESMAN', 7698, '1981-02-20', 1600, 300, 30);
  INSERT INTO emp VALUES( 7521, 'WARD', 'SALESMAN', 7698, '1981-02-22', 1250, 500, 30 );
  INSERT INTO emp VALUES( 7654, 'MARTIN', 'SALESMAN', 7698, '1981-09-28', 1250, 1400, 30 );
  INSERT INTO emp VALUES( 7844, 'TURNER', 'SALESMAN', 7698, '1981-09-08', 1500, 0, 30);
  INSERT INTO emp VALUES( 7876, 'ADAMS', 'CLERK', 7788, '1987-07-13', 1100, null, 20 );
  INSERT INTO emp VALUES( 7900, 'JAMES', 'CLERK', 7698, '1981-12-03', 950, null, 30 );
  INSERT INTO emp VALUES( 7934, 'MILLER', 'CLERK', 7782, '1982-01-23', 1300, null, 10 );

  INSERT INTO salgrade VALUES (1, 700, 1200);
  INSERT INTO salgrade VALUES (2, 1201, 1400);
  INSERT INTO salgrade VALUES (3, 1401, 2000);
  INSERT INTO salgrade VALUES (4, 2001, 3000);
  INSERT INTO salgrade VALUES (5, 3001, 9999);

  go
#+end_src

*** 其他题目

其他题目 (选作):

**** <RowGrid>

- 查询入职日期早于其直接上级的所有员工信息。
- 列出雇员中（除去mgr为空的人)工资第二高的人。
- 列出1981年来公司所有员工的总收入（包括sal和comm）
- 查询部门编号为 10 和 30 的所有人（用不同方式查询）
- 查询部门编号为 10 和 30 中名字中不含有 ‘C’ 的所有人
- 查询部门编号为 10 和 30 中名字首字母之外不含有 ‘C’ 的所有人

#+SPLIT: t
  
- 查询部门编号为 10 和 30 中所有的经理以及名字首字母之外不含有 ‘C’ 的所有人
- 查询纽约和芝加哥地区所有的经理以及名字首字母之外不含有 ‘C’ 的所有人
- 查询纽约和芝加哥地区所有的经理以及顶头上司名字的首字母之外不含有 ‘C’ 的所有人
- 查询每个人的工资等级
- 查询每个部门的平均工资的等级
- 查询每个组最高工资的那些人

** 练习题 题目1 的答案

查询除去 salesman 所有平均工资超过 2000 的部门:
 
#+begin_src sql
  -- 查询所有部门的平均工资
  select sal from emp;
  select avg(sal) from emp;
  select deptno, avg(sal) from emp group by deptno;

  -- 除去 saleman 之外的，所有部门的平均工资
  select deptno, avg(sal) from emp where job <> 'SALESMAN' group by deptno;

  -- 除去 saleman 之外的，所有部门的平均工资，超过 2000 的
  select * from (select deptno, avg(sal) as v from emp where job <> 'SALESMAN' group by deptno) x
     where v > 2000;
  select deptno, avg(sal) from emp where job <> 'SALESMAN' group by deptno having avg(sal) > 2000;

  -- 关联 dept 信息
  select * from dept where deptno in (
      select deptno from emp where job <> 'SALESMAN' group by deptno having avg(sal) > 2000
  );

  select dept.dname, avg(sal) from emp
      join dept on emp.deptno = dept.deptno
      where job <> 'SALESMAN'
      group by dept.dname
      having avg(sal) > 2000;

  select d.* from (select deptno from emp where job <> 'SALESMAN' group by deptno having avg(sal) > 2000) t 
    join dept d on t.deptno = d.deptno;
#+end_src

* <config>                                                           :NOEXPORT:

#+THEME: t1
#+EXPORT_LEVEL: 1

#+begin_src js
  const t1 = {
      ...defaultTheme,
      fontSizes: {
          text: "14px",
          monospace: "14px"
      },
      fonts: {
          text: "\"Helvetica Neue\", Helvetica, Arial, sans-serif"
      },
      space: [10, 8, 20],
      size: { width: "100%", height: "100%", maxCodePaneHeight: 100 }
  }
  const t2 = {
      ...t1,
      fontSizes: {
          text: "34px",
          monospace: "34px"
      },
  }
  console.log(defaultTheme);
#+end_src

#+begin_src css
  pre { margin: 5px 1em !important; }
  .example pre { background-color:transparent !important; margin: 0 2em !important; }

  ::-webkit-scrollbar {
    width: 5px;
    height: 80%;
  }

  ::-webkit-scrollbar-track {
    background: rgb(179, 177, 177);
    border-radius: 5px;
  }

  ::-webkit-scrollbar-thumb {
    background: rgb(136, 136, 136);
    border-radius: 5px;
  }

  ::-webkit-scrollbar-thumb:hover {
    background: rgb(100, 100, 100);
    border-radius: 5px;
  }

  ::-webkit-scrollbar-thumb:active {
    background: rgb(68, 68, 68);
    border-radius: 5px;
  }
#+end_src

** Components

#+EXTERN_COMPONENTS: ColFlexBox RowFlexBox RowGrid TaskBox

#+begin_src js
  const ColFlexBox = (props) => {
      return html`<${FlexBox} 
           style=${{flexFlow: "column wrap", justifyContent: "flex-start", alignItems: "stretch", height: "90%"}}
           ...${props}>
        </${FlexBox}>`
  };
  const RowFlexBox = (props) => {
      return html`<${FlexBox}
           style=${{flexFlow: "row nowrap", justifyContent: "flex-start", alignItems: "stretch", alignContent: "stretch" }}
           ...${props}>
        </${FlexBox}>`
  };
  const RowGrid = (props) => {
      const n = props.n || 2;
      return html`<${Grid} gridTemplateColumns=${"1fr ".repeat(n).trim()} ...${props}></${Grid}>`
  };
  const TaskBox = (props) => {
      return html`<${Box}  backgroundColor="rgba(0,0,0,0.2)" padding="10px" ...${props}></${Box}>`
  };
  const ScCodePane = (props) => {
      return html`<${Box} className="code-scroll"><${CodePane} ...${props}></${CodePane}></${Box}>`;
  }
#+end_src

#+begin_src css
  .code-scroll pre {
      height: 450px;
      overflow: auto;
  }
#+end_src
